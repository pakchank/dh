[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "2025 디지털인문학 겨울학교  워크샵",
    "section": "",
    "text": "본 웹사이트는 2025년 1월 23일 목요일 오후 1시반부터 4시15분까지 진행될  워크샵을 위한 사전 준비 및 강의 노트 제공을 위해 제공되고 있습니다. 워크샵 진행과 관련해서는 다음 연락처를 이용해 주시기 바랍니다.\n\n강의자: 박찬경 (chankyungpak@knu.ac.kr)\n조교:\n\n이신애 (leesa1257@naver.com)\n김윤아 (db00032@naver.com)\n\n오픈 채팅방\n\n또, 워크샵 참여 전에 다음 사전 설문조사에 반드시 참여해 주시기 바랍니다:\n\n사전 설문조사\n\n설문조사에 참여해주셔야 각 참여자의 현재 수준을 감안한 효율적인 워크샵 진행이 가능합니다.\n잠적적으로 워크샵에서 다룰 내용은 다음과 같습니다:\n\nAPI를 이용한 문서 DB 자료 이용\ntidytext를 이용한 한글 텍스트 분석\nAPI를 이용한 객체인식 알고리즘(NER) 이용\ntidygraph를 이용한 네트워크 분석\nggraph와 networkD3를 이용한 정적/동적 네트워크 시각화\nshiny를 이용해 웹으로 공개하기"
  },
  {
    "objectID": "5_basic.html#변수-함수-할당",
    "href": "5_basic.html#변수-함수-할당",
    "title": "R의 기초",
    "section": "변수, 함수, 할당",
    "text": "변수, 함수, 할당\nR의 작동 방식을 이해하기 위해서, 먼저 컴퓨터가 작동하는 방식에 대해서 간단하게만 복습해 봅시다. 컴퓨터에 데이터를 저장되는 곳은 크게 세 군데가 있습니다.\n\n연산장치(CPU, GPU) - 메모리 - 저장장치(HDD, SSD)\n\n이는 ’악마의 두뇌’를 가졌다고 일컬어지기도 하는 저 유명한 수학자 존 폰 노이만(John von Neumann; 1903-1957)이 고안해 낸 컴퓨터의 구조입니다. 아직 소개하지 않았지만, 여러분이 사용할 데이터들은 HDD, SSD와 같은 저장 장치에 살고 있습니다. 파일을 저장한다는 행위는 여러분들도 익숙하실 것이라고 믿습니다. 하지만, 여러분들이 데이터를 이용해서 어떤 계산을 하고 싶다면, 그 계산은 저장 장치가 아니라 ’연산장치’에서 일어납니다. CPU도 아마 많이 들어보셨을테고, 최근 인공신경망(ANN)이나, 암호화폐 채굴이 CPU 대신 GPU라는 연산장치 위에서 돌아간다는 이야기도 들어보셨을 것입니다. CPU건, GPU건, 컴퓨팅이라는 것은 결국 그 ’연산장치’들이 어떤 계산을 해 주기를 바라는 것이지요.\n문제는 저장장치에 있는 데이터를 연산장치가 바로 사용하는 것이 아니라는 것입니다. 연산장치가 계산을 하기 위해서는 중간 단계에 해당하는 메모리 위에 값이 기록되어야 합니다. 그리고 아마도 여러분들이 알고 계실 것처럼, 메모리에 기록된 데이터는 휘발합니다. 즉, 컴퓨터 전원이 꺼지면 없어지는 것이죠. 이 때문에 저장장치들이 필요합니다.\n그런데, 메모리에 대해서는 전원이 꺼지면 데이터가 휘발된다는 것 말고도꼭 알아야 하는 것이 있습니다. 메모리 위에 기록된 값은 ’이름’이 없으면 존재하지 않는 것이나 다름 없다는 사실입니다. 이게 무슨 말인지 알기 위해 다음과 같은 예를 살펴 봅시다.\n\n3+4\n\n[1] 7\n\n\n이러한 연산이 이루어지기 위해서는 3이라는 ’값’과 4라는 ’값’이 메모리에 먼저 기록되어야 합니다. 그 다음에 연산 장치가 메모리에 저장된 두 값을 더하는 ’연산’을 해 준 후, 그 결과 값이 7을 메모리 위에 기록합니다. 우리는 메모리 위에 기록된 결과를 모니터를 통해 보는 셈입니다. 그런데, 문제는 3, 4, 7이라는 모든 값에 별도의 이름을 붙이지 않았다는 것이지요. 앞서 말했듯이 ’이름’이 없는 값은 존재하지 않는 것이나 다름 없습니다. 따라서, 우리는 메모리에 쓰여진 이 값들을 다시 사용할 수 없습니다. 모니터에서 한 번 확인하고 날려보낸 것입니다.\n이는 반대로 이야기 하면, 이름을 부여한다면, 적어도 이름을 부여하는 프로그램, 즉 우리의 경우 R을 켜 놓은 동안은 재사용할 수 있다는 것입니다. 위의 프로그램을 다시 써 보죠.\n\na &lt;- 3\nb &lt;- 4\nc &lt;- a + b\nprint(c)\n\n[1] 7\n\n\n모니터에서 확인하는 결과는 같습니다. 그러나 우리는 몇 가지 작업을 더 했는데요, 3과 4를 각각 a와 b라는 이름에 할당(assign) 했습니다. 이름을 부여한 것이지요. 또 a에 해당하는 값과 b에 해당하는 값을 더한 결과 역시 c라는 이름에 할당했습니다. 이제 이 값들은 이름이 있으니 R을 켜둔 동안은 다시 불러 사용할 수 있는 것입니다.\n\na * b\n\n[1] 12\n\n\n다음 두 가지를 꼭 기억하세요. 이를 기억하고 있는 것은 앞으로 불필요한 에러를 피하는데 큰 도움이 됩니다.\n\n메모리 위에 쓰여진 값은 휘발한다 (전원이 꺼지면 없어진다)\n메모리 위에 쓰여진 값은 이름이 없으면 없는 것이나 다름 없다\n\n이제 앞으로 사용할 몇 가지 용어를 정의하도록 하죠.\n\n값(value): 데이터 그 자체\n변수(variable): 거기에 붙은 이름\n할당(assign): 값을 변수로 만드는 행위. R에서는 &lt;- 부호를 사용함. (사실은 =을 사용할 수도 있지만, 구분하겠습니다.)\n\n\n\n\n값-변수-할당의 관계\n\n\n사람의 언어에 비유해서 설명하자면, 값과 변수는 명사, 또는 목적어에 해당합니다. 많은 경우에는 이렇게 주어진 대상에 어떤 행위를 하고 싶어하지요. 우리는 그것을 연산이라고 합니다. 그리고 그러한 연산을 문법으로 표현한 것을 함수(function)라고 하지요. 인간의 언어에서라면 함수는 동사에 해당합니다.\n\n\n\n함수의 개념\n\n\n우리는 위의 예에서 이미 함수를 보았습니다. print()가 그것입니다. 이것은 주어진 값을 콘솔에 출력하는 동작을 의미하는 것이니 동사라고 할 수 있습니다. 그러면 동사와 명사를 구분하듯, R에서 변수와 함수를 구분할 수 있을까요? 구분할 수 있습니다. 여러 방법이 있지만, 가장 간단한 방법은 문자열 뒤에 괄호가 있는지 보는 것입니다. 변수는 괄호가 없습니다. 하지만, 함수는 print()처럼 괄호가 있지요.\n괄호는 왜 있는 것일까요? 괄호 안에 무언가를 써넣어야 하기 때문입니다. 즉, 함수가 표현하는 행위의 대상이 되는 목적어를 집어 넣어야 하기 때문이죠. 예컨대 print(c)에서 c라는 변수는 바로 그 목적어에 해당하요. 앞서 값이나 변수가 목적어의 역할을 하게 될 것이라고 했던 것을 기억할 것입니다. print(c)를 사람의 언어로 표현하면 다음과 같습니다.\n\nc를 콘솔에 print()하라.\n\n\n\n\n함수의 작동\n\n\n이렇게 값이나 변수가 함수가 하는 연산의 대상이 되면, 즉, 함수의 괄호 안에 들어가면, 이를 입력값(input), 또는 인수(argument)라고 합니다. 입력값을 받았으니 함수는 연산의 결과로 출력값(output)을 내어놓겠지요. 사실 더 정확한 표현은 다음과 같습니다.\n\nprint(x=c)\n\n[1] 7\n\n\n여기서 x는 print()라는 함수의 매개변수(parameter), c는 그 매개변수에 집어넣은 인수, 또는 입력값입니다. 매개변수는 print()라는 함수가 그 내부에서 사용하는 변수입니다. print()라는 함수는 내부에서 x라는 변수를 이용해 행위를 하지, c라는 함수 밖에 존재하는 변수에 대해서는 알지 못합니다. 그런데 x=c라고 하는 순간, 이용자는 함수에게 “네가 이용할 x가 바로 바로 c라는 변수에 들어있는 값이야”라고 연결해 주는 것입니다.\n[함수와 인수](pics/install/parameter_argument.pngㅑ{width=50%}\n그러면 print()는 자신이 이용하는 x라는 그릇에 c에 이미 연결되어 있는 값을 담고 그것을 출력하는 행위를 하게 됩니다.\n그런데 왜 첫번째 예에서는 x=을 생략하고 print(c)라고 했는데도 작동했을까요? 그것은 print() 함수 자체가 첫번째로 입력한 숫자를 x에 대응하는 인수로 자동으로 인식하도록 프로그램 되어 있기 때문입니다. 무언가를 출력하라고 하는 명령은 수없이 사용하게 될텐대, 매번 매개변수를 반복행 하면 너무 귀찮겠지요.\n그런데, 모든 함수가 인수를 필요로 하는 것은 아닙니다. 자연언어에서 동사 역시 자동사와 타동사로 구분되는 것과 같은 이치입니다. 예컨대 다음과 같은 함수는 인수 없이 실행 됩니다.\n\ngetwd()\n\ngetwd()라는 함수가 working directory 즉, 현재 R이 작업을 하고 있는 컴퓨터의 경로를 표시하는 동작을 의미하니, 인수가 따로 필요하지는 않겠지요. 어떤 경우에는 함수가 인수를 필요로 하지만 (즉, 타동사 이지만), 인수를 쓰지 않아도 작동하는 경우가 있습니다. 그런 경우에는 함수가 자신이 필요로 하는 인수에 대해 디폴트 값을 가지고 있는 경우 입니다. 즉, 사용자가 아무 인수도 주지 않으면 자동으로 인수로 가정하는 값이 있는 경우도 있다는 것입니다. 우리가 “밥 먹어”하는 대신 상대방이 알아들을만 한 상황에서는 “먹어”라고 하는 것과 비슷한 이치입니다."
  },
  {
    "objectID": "5_basic.html#데이터의-타입과-구조",
    "href": "5_basic.html#데이터의-타입과-구조",
    "title": "R의 기초",
    "section": "데이터의 타입과 구조",
    "text": "데이터의 타입과 구조\nR은 여러가지 종류의 데이터를 다룰 수 있습니다. 하지만 컴퓨터 프로그램은 인간처럼 연산을 하면서 주어진 데이터가 숫자인지, 문자인지 직관적으로 결정할 능력을 가지고 있지 않습니다. 연산이 이루어지기 전에 해당 데이터가 숫자인지, 문자인지, 미리 정해놓아야 합니다. 이렇게 정해 놓은 데이터의 종류를 데이터의 타입(Type)이라고 합니다. 그와는 달리, 타입을 가지고 있는 복수의 값을 엮어 놓는 방식도 여러가지가 있습니다. 우리는 그 다양한 방식들을 데이터의 구조(Structure)라고 부를 것입니다. 데이터의 타입과 구조는 매우 많은 종류가 있고, 심지어 이용자가 만들어낼 수도 있는데, 여기서는 일반적인 데이터 분석 및 시각화를 위해 자주 사용하게 되는 것만 짚고 넘어가려고 합니다.\n\n데이터 타입\n\nnumeric: 1, 1.2, -3.42와 같이, 우리가 일상생활에서 사용하는 실수의 개념에 가깝습니다.\ncharacter: 이는 문자를 의미합니다. “a”, “b”, “3-2”와 같이 따옴표로 둘러싸 문자를 표현합니다. 사람의 눈에는 숫자이더라도 “1”라고 쓰면 R은 이를 문자로 인식합니다. 따라서 \"1\"-\"2\"와 같은 명령어를 치면 에러가 발생합니다.\nlogical: 이는 TRUE 또는 FALSE 두 개의 값을 갖는 논리 연산을 위한 데이터 타입 입니다. 따옴표를 사용하지 않고, 대문자로만 표기했다는 것에 유의하세요. R은 소문자와 대문자를 구분하기 때문에, True 또는 False라고 쓰는 순간 완전히 다른 의미를 가지게 됩니다. 또 \"TRUE\", \"FALSE\"라고 쓴다면, logical 타입이 아닌 character 타입으로 인식됩니다. logical 타입은 다른 언어에서는 Boolean 타입이라고 불리기도 합니다.\n\n그 외에 특별한 데이터가 있습니다. NA는 값이 없음을, NaN은 계산 결과가 숫자로 표현될 수 없었음을 이야기 합니다. 예컨대, 0을을 0으로 나누려고 한다면, 그 결과값은 NaN이 됩니다.\n\n0/0\n\n[1] NaN\n\n\n정수를 뜻하는 integer, 복소수를 뜻하는 complex 타입도 있지만 당장 다룰 일이 별로 없을 것이므로, 건너뛰도록 하겠습니다. 또 하나 중요한 데이터 타입으로는 factor라는 것이 있는데요, 이것은 바로 이해가 어려우니, 나중에 사용할 때 설명하도록 하겠습니다.\n\n\n데이터 구조\nR의 특이한 점 중 하나는 한 개의 값이 따로 존재한다는 개념이 없다는 것입니다. 이상하게 들리겠지만, 일단 이해를 위해 다음과 같은 예를 보도록 하죠.\n\n2\n\n[1] 2\n\n\n콘솔에서 2라고 치고 엔터를 누르면, R은 이 값을 그대로 반복해서 보여주는데요, 그 옆에 [1]이라고 쓰여져 있는 것이 보일 것입니다. 그것은 2가 값들을 모아놓은 집합의 첫번째 요소라는 뜻입니다. 우리에게는 그냥 하나의 숫자 같지만, R은 여러개의 값을 담을 수 있는 그릇이 있는데, 그 안에 들어있는 값이 하필이면 한 개 였고, 그 한 개의 값이 첫번째 요소이니(물론 마지막 요소이기도 합니다) [1]이라고 표시한 것입니다. 이렇게 R은 항상 모든 값이 여러개의 값을 가질 수 있는 그릇에 담겨있다고 생각하고, 그릇이 없는 값 같은 것은 존재하지 않는다고 봅니다. 이렇게 값들을 담을 수 있는 그릇을 데이터 구조(structure)라고 부릅니다.\n\n(1) 벡터(vector)\nR이 사용하는 가장 간단한 데이터 구조는 벡터 입니다. 벡터는 같은 데이터 타입을 가진 값들의 순서가 있는 집합이라고 생각하면 좋습니다. 사실 위에서 본 [1] 2라는 출력 값은 “2라는 값 하나만 가지고 있는 벡터”라는 뜻입니다. 이제 여러개의 값이 담겨 있는 벡터를 보겠습니다.\n\nvecNum &lt;- c(1,2,3,4,5)\nvecNum\n\n[1] 1 2 3 4 5\n\n\n\nvecChar &lt;- c('a', 'b', 'c')\nvecChar\n\n[1] \"a\" \"b\" \"c\"\n\n\n위에서 보듯 c()라는 함수를 이용해서 여러 개의 값을 만들 수 있습니다. 또 값을 변수에 할당하는데 사용했던 &lt;- 연산자를 이용해 벡터 전체를 하나의 변수에 할당할 수도 있습니다. 위의 예에서 vecNum은 numeric 데이터 타입만을 가지고 있는 벡터이지만, vecChar의 경우에는 character 타입으로만 이루어진 벡터입니다.\n\n\n\n(2) 리스트(list)\n리스트는 ‘키(key)’라고 불리는 데이터의 이름과 그에 상응하는 ’값(value)’ 사이의 연결로 표현되는 데이터 구조 입니다. 이렇게 말하면 조금 난해하지만, 예를 보면 간단합니다.\n\npersons &lt;- list(id = c(1, 2, 3),\n                gender = c(\"Male\", \"Female\", \"Female\"),\n                height = c(173, 165, 170))\npersons\n\n$id\n[1] 1 2 3\n\n$gender\n[1] \"Male\"   \"Female\" \"Female\"\n\n$height\n[1] 173 165 170\n\n\n위의 예에서 c(1,2,3)과 같은 정보는 ’값’에 해당하고, id, gender, height과 같은 값들은 이 값들과 연결된 ’키’에 해당합니다. 이렇게 리스트를 만들어 놓으면 벡터보다 직관적으로 데이터의 관심있는 일부분을 불러올 수 있습니다. 예컨대 위에서 만든 리스트에 담긴 3명에 대한 정보 중, 성별만을 알고 싶다면 다음과 같이 명령하면 됩니다.\n\npersons$gender\n\n[1] \"Male\"   \"Female\" \"Female\"\n\n\n위의 예에서 바로 알 수 있듯이 $ 연산자는 리스트에서 특정 키에 해당하는 값을 부르기 위한 역할을 합니다. 당장은 리스트 보다 벡터를 자주 사용하게 되겠지만, 곧 리스트가 유용한 경우가 자주 발생하게 됩니다.\n\n\n(3) 데이터프레임(Data Frame)\n데이터 프레임은 우리가 잘 알고 있는 표(table)를 의미합니다. 예컨대 위에서 사용한 리스트의 예를 데이터 프레임으로 만들어 볼까요?\n\ndf &lt;- data.frame(id = c(1, 2, 3),\n                 gender = c(\"Male\", \"Female\", \"Female\"),\n                 height = c(173, 165, 170))\ndf\n\n  id gender height\n1  1   Male    173\n2  2 Female    165\n3  3 Female    170\n\n\n우리에게 익숙한 테이블 모양으로 출력이 된다는 것을 알 수 있습니다. 예컨대 데이터로 엑셀 파일이 있어 이를 R을 이용해 분석하려 한다면, 이렇게 데이터프레임으로 인식시키는 것이 가장 직관적이겠지요. 데이터 프레임은 여러분들이 가장 자주 보게 될 데이터 구조 입니다."
  },
  {
    "objectID": "5_basic.html#서브세트subset",
    "href": "5_basic.html#서브세트subset",
    "title": "R의 기초",
    "section": "서브세트(Subset)",
    "text": "서브세트(Subset)\n앞서 리스트에 대해 이야기 하면서 $ 연산자를 통해 데이터의 일부만 보는 작업의 예를 보았습니다. 이렇게 데이터의 일부만 보는 행위를 서브세트라고 합니다. 서브세트를 분석 목적에 맞게 잘 하는 것은 데이터 과학에서 가장 중요하고, 자주 하게 되는 테크닉 입니다. 우리는 여기서 배우는 서브세트 기술 보다 조금 더 명료한 방법을 앞으로 사용하게 되겠지만, 이를 100% 피해갈 수는 없으므로, 가장 기초적인 것만 보도록 하겠습니다.\n\n벡터\n일단 벡터의 서브세트를 이해하기 위해 다음과 같은 예를 보겠습니다.\n\na &lt;- c(4, 5, 6, 7, 8)\na[2]\n\n[1] 5\n\n\n이렇게 벡터를 서브세트 하기 위해서는 간단하게 [] 안에 몇 번째 값을 보고 싶은지를 써 주면 됩니다. 이런 것도 가능합니다.\n\na[2:4]\n\n[1] 5 6 7\n\n\n여기서 2:4는 “2에서 4까지의 정수”라는 뜻으로 c(2,3,4)라고 쓴 것과 동일한 효과를 갖습니다. 따라서, 두번째, 세번째, 네번째 값이 서브세트 된 것이지요. 또 이런 방식으로 특정 순서에 있는 값만 제외하는 것도 가능합니다.\n\na[-2]\n\n[1] 4 6 7 8\n\n\n\n\n리스트\n이번엔 아까 썼던 것과 같은 리스트 예를 사용해 보겠습니다.\n\npersons &lt;- list(id = c(1, 2, 3),\n                gender = c(\"Male\", \"Female\", \"Female\"),\n                height = c(173, 165, 170))\n\n아까 persons$gender라고 써서 subset하는 방식으로 봤습니다. 똑같은 효과를 갖는 명령어로 다음과 같이 쓸 수 있습니다.\n\npersons[[\"gender\"]]\n\n[1] \"Male\"   \"Female\" \"Female\"\n\n\n대괄호를 두번 써 주었다는 것(‘[[’)에 유의해 주세요. 정확하게 같은 결과가 나오지만, 이 때는 키(key)를 따옴표를 써서 문자열로 제시해 주어야 합니다. 사실 persons$gender는 이 코드를 조금 더 간단하게 쓰기 위한 약어라고 생각하시면 되겠습니다. 사실 gender는 persons 리스트에서 두번째 키이기 때문에 다음과 같이 써도 결과는 같습니다.\n\npersons[[2]]\n\n[1] \"Male\"   \"Female\" \"Female\"\n\n\n대괄호를 한번 쓰는 것은 조금 다른 의미를 갖습니다.\n\npersons[2]\n\n$gender\n[1] \"Male\"   \"Female\" \"Female\"\n\n\n결과에서 보는 것처럼, persons[[2]]는 persons라는 list의 두번째 키/값의 쌍에서 값만 되돌려달라는 의미입니다. 따라서 되돌려받는 값은 값에 해당하는 벡터, c(\"Male\", \"Female\", \"Female\")이 됩니다. 반면, persons[2]는 두 번째 키/값의 쌍 전체를 돌려달라는 돌려달라는 의미이므로, 반환값 역시 리스트인 list(gender = c(\"Male\", \"Female\", \"Female\")) 형태가 됩니다. 따라서, persons[2:3]과 같은 표현도 자연스럽게 정의가 되겠지요.\n\n\n데이터프레임\n사실 여러분은 데이터프레임을 서브세트 할 일이 가장 많을 것입니다. 사실 데이터프레임을 서브세트 하는 방식은 리스트와 매우 유사합니다. 아까 만든 df 데이터프레임을 생각해 보면,\n\ndf$gender\n\n[1] \"Male\"   \"Female\" \"Female\"\n\n\n는 리스트처럼 gender열의 값에 해당하는 벡터를 돌려주고, 이는 다음과 같습니다.\n\ndf[['gender']]\n\n[1] \"Male\"   \"Female\" \"Female\"\n\n\n반면 숫자를 이용한 서브세팅도 리스트와 유사합니다.\ndf[[2]]라고 하면 두번째 열(column)에 해당하는 벡터를, df[2]라고 하면 두번째 열을 그 값에 해당하는 벡터값만이 아니라, 열의 이름인 gender가 더해진 열 한 개짜리 데이터프레임을 돌려줍니다. 그런데, 이런 방식 말고 리스트와 다른 방식의 서브세팅도 있습니다. 이는 데이터프레임을 다룰 때에는 값을 취할 행과 열을 모두 지정해 주는 경우도 많기 때문이지요. 그 방식은 다음과 같습니다.\n\ndf[2,3]\n\n[1] 165\n\n\n이 명령어는 두 번째 행, 세 번째 열에 해당하는 값을 취하라는 뜻입니다. 그렇다면 앞에서 배운 : 연산자를 이용해 다음과 같은 표현도 가능합니다.\n\ndf[1:2, 2:3]\n\n  gender height\n1   Male    173\n2 Female    165\n\n\n물론, 이는 첫번째 부터 두번째 행, 두번째부터 세번째 열에 해당하는 값을 데이터프레임 형태로 되돌려달라는 의미입니다.\n이렇게 연속된 숫자를 이용한 서브세팅 말고 첫번째와 세번째 열에 해당하는 값을 돌려달라고 할 수도 있겠지요? 이 때는 숫자로 이루어진 벡터를 이용합니다.\n\ndf[ , c(1,3)]\n\n  id height\n1  1    173\n2  2    165\n3  3    170\n\n\n그런데 이번에 행을 지정하는 부분 (쉼표 앞 부분)이 비어 있습니다. 이는 행 전체에 해당하는 정보를 달라는 것을 뜻합니다.\n이것 말고도 서브세팅에 이용할 수 있는 기술은 몇 가지 더 있는데요, 우리는 사실 이 방식을 사용하지 않을 예정입니다. 왜냐하면, 이렇게 R이 기본적으로 제공하는 방식은 가독성이 그리 좋지 않아, 몇 일만 지나도 내가 무엇을 하려고 했던 것인지 잊어버리는 경우가 많습니다. 예컨대, 위의 예에서 첫번째, 세번째 열이 무엇이었는지 기억하는 사람은 별로 없겠지요. 또 내가 스스로 쓴 코드를 이해하기 어렵다는 것은 다른 사람이 이해하기는 더 어렵다는 뜻입니다. 이는 협업을 자주 해야 하는 데이터 저널리즘에서는 치명적인 문제라고 할 수 있습니다. 따라서 우리는 다음 장에서 가독성과 협업 효율성이 높은 다른 방식을 이용할 것입니다."
  },
  {
    "objectID": "5_basic.html#조건predicate",
    "href": "5_basic.html#조건predicate",
    "title": "R의 기초",
    "section": "조건(Predicate)",
    "text": "조건(Predicate)\n여기서 말하는 조건은 쉽게 말하면 질문 입니다. 코딩을 하다보면 질문을 할 일이 정말 많은데요, 특히 우리가 자주 사용하는 조건(Predicate)을 이용한 질문들은 그 대답이 logical 값, 즉, TRUE 또는 FALSE가 됩니다. R에게 참, 거짓을 물어보는 방식은 아주 많은데요, 그 중 아주 많이 사용하는 것들로는 다음과 같은 것들이 있습니다.\n\n==, !=, %in%, is.na(), &gt;, &gt;=, &lt;, &lt;=\n\n==는 “두 값이 같은지”를 물어보는 것입니다. 예컨대,\n\n2 == 2\n\n[1] TRUE\n\n\n\n2 == 3\n\n[1] FALSE\n\n\n\na &lt;- 2\na == 2\n\n[1] TRUE\n\n\n등이 가능합니다. 마지막 예에서 알 수 있듯이, == 앞 뒤에는 값이 와도, 변수명이 와도 좋습니다. 여기서 등호가 2개라는 것에 유의하세요. R에서 =와 ==는 전혀 다른 것입니다. =는 &lt;-와 유사하게 할당의 의미로, ==는 질문의 의미로 사용합니다.\n반면, !=는 “구 값이 다른지”를 물어보는 것이겠지요. 예컨대,\n\n2 != 3\n\n[1] TRUE\n\n\n두 값이 다르기 때문에 이에 대한 대답은 TRUE 입니다. 반면 2!=2의 답은 FALSE겠지요. !=은 등호 앞에 !를 붙여서 만드는데, !는 R에서 not을 의미합니다.\n%in%은 해당 연산자 앞의 값이 연산자 뒤에 나오는 벡터에 속하는지를 물어보는 조건 입니다. 예컨대 다음과 같은 방식입니다.\n\n2 %in% c(2,3,4,5)\n\n[1] TRUE\n\n\n\n6 %in% c(2,3,4,5)\n\n[1] FALSE\n\n\n마지막으로 in.na()는 결측값이 있는 곳에 TRUE를 되돌려주는 조건입니다.\n\nis.na(c(2,3,NA,5))\n\n[1] FALSE FALSE  TRUE FALSE\n\n\nis.na()는 앞에서 다룬 조건들과 몇 가지 점에서 조금 다릅니다. 먼저, 질문을 하는 방식에 두개의 다른 값을 이용하는 것이 아니라 하나의 값(위의 예에서는 벡터 c(2,3,NA,5))만을 사용합니다. 둘째, 그렇기 때문에 조건의 형태가 일반 함수 형태로 되어 있고, 괄호 안에 질문의 대상이 되는 값을 써 넣도록 되어 있습니다. 셋째, 대답이 하나의 TRUE 또는 FALSE가 아니라, 벡터의 모든 요소에 대해서 주어집니다. 세번째 요소만 결측값이니, 답이 c(FALSE, FALSE, TRUE, FALSE)가 되는 것이지요. 만약 반대로 “결측값이 아닌 곳”을 찾으려 한다면, !이 부정을 의미한다고 하였으니 다음과 같이 쓰면 되겠지요.\n\n!is.na(c(2,3,NA,5))\n\n[1]  TRUE  TRUE FALSE  TRUE"
  },
  {
    "objectID": "5_basic.html#패키지-개념-이해하기",
    "href": "5_basic.html#패키지-개념-이해하기",
    "title": "R의 기초",
    "section": "패키지 개념 이해하기",
    "text": "패키지 개념 이해하기\nR뿐만 아니라, 많은 다른 언어에서 ’패키지’라고 하는 것은 쉽게 말하자면 유용한 함수들의 묶음을 의미합니다. 기본 R을 설계한 사람들이 R에 내장해두지는 않았지만, 특정 목적을 위해서는 유용함 도구들이 묶여서 ’패키지’로 제공된다고 생각하면 되겠습니다. 비유하자면, 여러분들이 매일 사용하는 ’카카오톡’이 R이라고 해 보죠. 카카오톡 안에는 기본적인 채팅 기능 안에도 수많은 다른 기능들이 있지요? 선물을 주고 받을 수도 있고, 음식을 주문할 수도 있고, 쇼핑을 할 수도 있습니다. 물론 모든 이용자들이 이 기능들을 모두 사용하지는 않지요. 하지만, 어떤 사람들은 자주 사용합니다. 이러한 세부 기능에 해당 하는 일종의 카카오톡 안의 ’미니 프로그램’을 R에서는 패키지라고 부른다고 생각하면 되겠습니다.\n\n\n\n카카오 미니프로그램\n\n\nR에서 패키지를 부르는 방법은 다음과 같습니다.\n\nlibrary(stats)\n\nlibrary()는 괄호가 있으니, 패키지를 부르는 ’함수’일 것이고, 괄호 안에는 부르고 싶은 패키지의 이름을 따옴표 없이 쓰면 됩니다. 여기서는 R을 설치할 때 같이 설치되는 stats라는 패키지를 불렀습니다.\n\n\n\n패키지 종류\n\n\n그런데 R이 설치될 때 모든 패키지가 함께 설치되는 것은 아닙니다. 사실 그렇지 않은 패키지가 훨씬 많지요. 심지어 패키지는 여러분도 만들 수 있습니다. 그렇게 개인이 여러 목적으로 만든 비공식 패키지까지 포함한다면, 세상에는 무한히 많은 R 패키지들이 있습니다. 하지만, 우리가 자주 사용하게될 패키지는 R개발진들의 관리 감독 아래 있는 ‘공식’ 패키지들입니다. 공식 패키지이지만, R과 함께 설치되지 않는 패키지를 설치하기 위해서는 다음과 같은 함수를 실행시키면 됩니다 (여기서는 따옴표가 필요합니다!).\n\ninstall.packages(\"tidyverse\")\n\n예, 우리가 사용한다고 했던 바로 그 tidyverse 입니다. tidyverse 문법을 이용하기 위해서 몇 가지 추가적인 함수가 필요하다고 했지요? 이렇게 설치된 tidyverse 패키지 안에 우리가 사용하고자 하는 바로 그 함수들이 포함되어 있습니다.\n물론, 설치만 한다고 해서 바로 이 패키지를 사용할 수 있는 것은 아닙니다. 아까 stats 패키지의 예에서처럼, tidyverse 패키지도 다음과 같이 불러주어야 합니다.\n\nlibrary(tidyverse)\n\n이 함수를 실행시키면 tidyverse 문법을 사용할 준비가 된 것입니다.\n\n패키지 사용시 주의사항: 설치? 로드?\n방금 tidyverse 패키지를 설치하고 불러왔는데요, 여기서 패키지를 ’설치’한다는 것과 ’불러온다’는 것의 의미에 대해 잠깐 생각해볼 필요가 있습니다.\n여러분이 일상적으로 윈도우 또는 맥OS 상에서 어떤 소프트웨어를 ‘설치’하면 그것은 어디에 저장되었다는 것을 의미하나요? 당연히 HDD, SSD와 같은 ’저장장치’ 입니다. 그래야, 컴퓨터를 껐다 다시 키더라도, 다시 ’설치’할 필요가 없을테니까요. tidyverse 패키지를 설치했다는 것도 비슷한 의미입니다. 설치한 패키지는 저장장치 어디엔가 저장되어 있습니다.\n\n따라서, 설치는 한 번 했다면 다시 할 필요가 없습니다.\n\n그런데 여러분 설치한 소프트웨어가 항상 켜져있나요? 물론 아닙니다. 그 소프트웨어를 실행시켜야지요. 실행시킨다는 것은 뭘까요? 여러 의미가 있지만, 가장 기본적으로는 저장장치에 설치되어 있는 해당 프로그램을 컴퓨터 메모리 상에 ’불러온다’는 것입니다. 가끔 여러분들 너무 많은 소프트웨어를 동시에 열어두면 컴퓨터가 느려져서 몇몇 사용하지 않는 프로그램을 꺼야했던 경험이 있을 것입니다. 프로그램을 껐다는 것은 반대로 메모리에서 지운다는 것을 의미하겠지요. 따라서 메모리에 여유 공간을 조금 확보하려고 프로그램을 끄는 것입니다. 이렇게 프로그램을 켠다는 것은 R 패키지로 치면 패키지를 로드하는 과정과 유사합니다.\n아까의 예에서처럼 library(tidyverse)라는 함수를 실행시키면, 저장장치에 저장되어 있던 tidyverse 패키지가 메모리로 불러와집니다. 그런데 메모리는 어떤 특성을 가지고 있었나요? 컴퓨터를 꺼도, 해당 정보에 할당된 이름이 사라져도, 메모리에서 언제든 사라질 수 있습니다. 이것은 무슨 이야기일까요? 여러분들이 Rstudio를 끄는 순간, 또는 Rstudio 안에서 다른 프로젝트로 이동하는 순간, 불러왔던 패키지는 메모리에 존재하지 않는 것이 됩니다. 그러니,\n\n패키지를 불러오는 것은 Rstudio를 새로 켤 때마다, 또는 새로운 프로젝트로 이동할 때마다, 매번 다시 해야 합니다!\n\n또 한 가지, 여러분들에게 당장 자주 일어나지는 않을 일이지만, 여러 개의 패키지를 로드해서 사용하다보면 간혹 생기는 문제가 있습니다. 바로 다른 두 개의 패키지가 하나의 함수명을 공유하고 있는 경우 입니다. 예컨대, MASS라는 패키지에도 select()라는 함수가 있고, tidyverse 패키지에도 select() 함수가 있습니다. 기능도, 문법도 완전히 다르지요. 따라서, 후자를 생각하고 select() 함수를 썼다가 에러가 발생하는 경우가 있습니다. 여러 방법이 있지만, 이럴 때에는 tidyverse::select()라고 써 주세요. 그러면, tidyverse 패키지에 속하는 select() 함수를 사용하게 됩니다."
  },
  {
    "objectID": "5_basic.html#tidyverse-처음-사용하기",
    "href": "5_basic.html#tidyverse-처음-사용하기",
    "title": "R의 기초",
    "section": "Tidyverse 처음 사용하기",
    "text": "Tidyverse 처음 사용하기\n이제 겨우 tidyverse 문법을 사용할 준비가 되었습니다. 물론 tidyverse 패키지의 설치와 불러오기를 잊지 마세요! 사실 tidyverse는 많은 다양한 코딩 방식, 시각화 방식, 데이터 타입과 구조에 대한 재정의 등을 포함한 광범위한 코딩 패러다임인데요, 우리는 학습 목적상 다음 두 가지에만 주목하려고 합니다.\n\n서브세트\n파이프(pipe)\n\n그 외에 tidyverse의 다른 요소들은 학습이 심화되면서 차차 마주하게 될 것입니다.\n첫번째, 서브세트는 우리가 앞장에서 이미 보았던 서브세트, 즉, 데이터의 일부만을 취하는 방법입니다. R은 이미 좋은 서브세트 기능을 제공하지만, 앞서 말했듯 해당 문법이 가독성이 아주 좋지는 않다고 했습니다. 따라서 tidyverse에서 제공하는 방식의 서브세트를 이용할 것입니다. 두번째 ’파이프’는 긴 코드를 연결해서 간결하게 작성하는데 필요한 일종의 코드 작성법 입니다. 차례차례 살펴보지요.\n\n서브세트\ntidyverse의 서브세트는 기본적으로 R 데이터구조 중 데이터프레임에 적용되는 것입니다. 벡터나 리스트를 사용할 때에는 기본 R 문법을 사용하면 됩니다. 데이터프레임을 서브세트 하는 방법에는 행을 취하는 방법과 열을 취하는 방법이 있었습니다. 다음을 기억해 두세요. tidyverse에서는:\n\n열을 취할 때에는 항상 select()함수와 열의 ’이름’을 사용합니다.\n행을 취할 때에는 항상 filter()함수와 행을 취하는 ’조건’을 사용합니다.\n\n이것만 이해하면 거의 모든 것을 이해한 것과 다름 없습니다. 일단, tidyverse 서브세트는 데이터프레임에 관한 것이라고 했으니, 일단 앞서 이미 이용했던 것고 같은 데이터 프레임을 다시 만들어 예제 데이터로 이용해 보지요.\n\ndf &lt;- data.frame(id = c(1, 2, 3),\n                 gender = c(\"Male\", \"Female\", \"Female\"),\n                 height = c(173, 165, 170))\ndf\n\n  id gender height\n1  1   Male    173\n2  2 Female    165\n3  3 Female    170\n\n\n열을 취할 때는 select() 함수와 열의 이름을 사용한다고 했으므로, 다음과 같이 씁니다.\n\nselect(df, gender)\n\n  gender\n1   Male\n2 Female\n3 Female\n\n\n즉, select() 함수의 첫번째 인수는 서브세트의 대상이 될 데이터프레임(df), 두번째 인수는 거기서 선택할 열의 이름(gender)입니다. 그런데, 사실 복수의 열을 선택할 수도 있습니다.\n\nselect(df, gender, height)\n\n  gender height\n1   Male    173\n2 Female    165\n3 Female    170\n\n\n즉, 인수로 열의 이름을 그냥 나열하면 된다는 것입니다.\n행을 취할 때는 filter() 함수와 행을 취할 조건을 사용한다고 했습니다. ’조건’이라는 말을 앞장에서 보았지요? 바로 TRUE, FALSE를 뱉어내는 R에게 질문하는 방식이라고 설명했던 바로 그 조건 입니다. 따라서, 키가 170이 넘는 사람에 관한 행만을 취하고 싶다면, 다음과 같이 쓰면 됩니다.\n\nfilter(df, height &gt;= 170)\n\n  id gender height\n1  1   Male    173\n2  3 Female    170\n\n\nfilter() 함수의 첫 인수 역시 데이터프레임이고, 그 인수로는 조건이 옵니다. 그렇다면 두 개의 조건을 사용할 때는요? 그 때는 두 개의 조건이 AND 관계인지, OR 관계인지를 밝혀야 합니다. 그 관계를 밝히는 기호는 다음고 같습니다.\n\nAND: 조건1 & 조건2\nOR: 조건1 | 조건2\n\n이제 다음과 같은 예를 보세요.\n\nfilter(df, height &gt;= 170 & gender==\"Female\")\n\n  id gender height\n1  3 Female    170\n\n\n이것은 여성’이고(AND)’ 키가 170 이상인 사람에 해당하는 행을 돌려달라는 것이겠지요? 반면,\n\nfilter(df, height &gt;= 170 | gender==\"Female\")\n\n  id gender height\n1  1   Male    173\n2  2 Female    165\n3  3 Female    170\n\n\n이것은 여성’이거나(OR)’ 키가 170 이상인 사람에 해당하는 행을 돌려달라는 것이겠지요? 이는 데이터 전체에 해당하네요.\n\n\n파이프\n파이프는 코드를 길게 써야 할 때 필요한 사용하는 코딩 스타일 입니다. 파이프를 위해서는 ’파이프’로 불리는 기호가 하나 필요합니다. 바로 다음 기호 입니다.\n\n\n\n파이프\n\n\n이 간단한 기호가 어떻게 긴 코드를 작성하는데 도움을 준다는 것일까요?\n위의 그림에서 볼 수 있는 것처럼, 파이프는 함수의 첫 번째 인수를 함수의 왼쪽에 쓸 수 있게 해줍니다. 이제 데이터에 함수를 두 번 연속적으로 적용해야 하는 경우를 생각해 볼까요? 일반적인 문법에서는 우리가 중학교 수학 시간에 배운 것과 같이 다음과 같이 쓰면 됩니다.\n\ndo_this_next(do_this_first(data))\n\n이를 조금 풀어서 설명하면, 원 데이터(data)에 do_this_first() 함수를 먼저 적용하고, 그 결과에 do_this_next() 함수를 적용하는 것이지요. 물론 이렇게 써도 아무 문제가 없습니다. 하지만, 이런 방법에는 큰 문제가 있습니다. 바로 코드를 오른쪽에서 왼쪽으로 읽어야 한다는 것이지요. 이는 우리가 자연스럽게 글을 읽는 방식과 반대입니다. 사실, 이렇게 함수가 두 개 뿐이라면 큰 문제가 아니겠지만, 함수가 더 많아지면 가독성이 더욱 떨어집니다.\n\nfinally_do_this(then_do_this(do_this_next(do_this_first(data))))\n\n현실적으로는 함수를 십수개 차례대로 적용해야 하는 경우도 많으니, 이러한 방식의 코드는 나중에 스스로가 리뷰하기도 어려울 뿐더러, 협업 상황이라면 상황은 더욱 악화됩니다. 그래서 전통적으로는 이런 방식의 코드를 많이 사용해 왔습니다.\n\ndata2 &lt;- do_this_first(data)\ndata3 &lt;- do_this_next(data2)\ndata4 &lt;- then_do_this(data3)\nfinally_do_this(data4)\n\n즉, 함수를 실행하고 그 결과를 변수로 저장한 다음, 다음 함수에 해당 변수를 인수로 사용하는 방식이지요. 읽기 조금 수월한가요? 어느 정도는 괜찮습니다. 하지만, 이것도 결코 읽기 쉬운 코드라고 할 수는 없습니다. 또 그 내용을 알기 어려운 data2, data3, data4 등의 불필요한 데이터들이 계속해서 생성됩니다. 이 역시 가독성을 낮출 뿐더러, 불필요하게 메모리를 차지하게 됩니다. 데이터의 이름을 조금 더 이해하기 쉽게 만들면 좋겠지만, 이렇게 데이터 처리 와중에 생긴 데이터에 모두 이름을 붙일만한 의미가 있는 것도 아니고, 데이터 이름을 자꾸 만들다보면, 더 이상 이름을 만들 아이디어도 떠오르지 않게 됩니다(이건 농담이지만, 진담이기도 합니다!).\n우리가 파이프를 쓴다면 다음과 같이 쓸 수 있습니다.\n\ndata |&gt;\n    do_this_first() |&gt;\n    do_this_next() |&gt;\n    then_do_this() |&gt;\n    finally_do_this()\n\n이 코드를 잘 보면 항상 파이프 왼쪽에서 발생한 결과가 다음 함수의 투입값(input)이 됩니다. 이 코드는 우리가 글을 읽는 방식과 동일한 순서에 따라 쓰여졌기 때문에 읽기 쉬울 뿐더러, 필요 없는 중간 단계의 데이터(data2, data3 따위)도 만들지 않았습니다. 우리는 앞으로 연속해서 함수를 적용해야 할 때, 위의 예와 같이 파이프를 사용할 것입니다. 여러분도 가능한 위의 코딩 스타일을 사용하도록 노력해 보세요!\n\n\n(3) 서브세트와 파이프를 동시에!\n이제 tidyverse 문법의 주요 구성 요소라고 말한 서스세트와 파이프를 결합해 보겠습니다. 이제 앞서 사용했던 예에서 특정 열을 선택하고, 또 어떤 조건에 따라 행도 선택한다고 해 보지요. 그러면 다음과 같이 쓸 수 있을 것입니다.\n\ndf |&gt;\n    filter(height &gt;= 170 & gender==\"Female\") |&gt;\n    select(gender, height)\n\n  gender height\n1 Female    170\n\n\n코드를 잘 살펴보면 그 의미는 다음과 같습니다.\n\n\n원데이터 df에서 키가 170이 넘고, 여성인 행의 데이터를 취하라.\n그런 다음, gender, height 칼럼만 표시하라.\n\n\n파이프를 썼기 때문에, filter() 함수와 select() 함수 안에는 데이터가 인수로 들어가지 않는다는 것에 주목하세요! 파이프를 사용하면 서브세트 할 데이터는 두 함수 앞에 사용한 파이프의 왼쪽에 있게 됩니다!\n다음 내용으로 넘어가기 앞서, 위의 코드를 꼭 이해해야 합니다! 여러분은 이 책을 모두 읽을 때까지 비슷한 코드를 수십번 보고, 사용하게 될테니까요."
  },
  {
    "objectID": "5_basic.html#프로젝트",
    "href": "5_basic.html#프로젝트",
    "title": "R의 기초",
    "section": "프로젝트",
    "text": "프로젝트\n프로젝트가 어떤 기능인지를 이해하기 위해서는 working directory, 즉 작업경로라는 개념을 이해해야 합니다. 작업경로는 현재 R이 자신이 위치하고 있다고 생각하는 저장장치 안의 폴더를 의미합니다. 보통은 지금 작성하고 있는 코드가 저장되어 있는 곳이 작업폴더가 되지만, 이는 경우에 따라 다릅니다. 현재 작업 폴더가 어디인지를 알기 위해서는 다음과 같은 명령어를 콘솔에서 실행해 보세요.\n\ngetwd()\n\n작업폴더가 중요한 이유는, 저장장치로부터 R이 데이터를 불러올 때, 특별한 이야기가 없으면 작업폴더로부터 불러와야 한다고 생각하기 때문입니다. 하지만, R이 현재 작업폴더로 이용하고 있는 장소와 이용자가 작업폴더라고 믿고 있는 장소 사이에 차이가 있는 경우가 종종 있습니다. 프로그래밍을 처음 해 보시는 분들이 처음에 제일 많이 겪는 에러의 원인입니다.\n작업폴더의 문제를 해결하는 방법은 여러가지가 있지만, 하나의 보도 프로젝트를 위한 코드와 데이터, 즉 모든 파일은 항상 하나의 폴더 안에 저장해 놓도록 ’약속’하는 것입니다. 그 약속을 R에서는 프로젝트라고 부릅니다. Rstudio에서 프로젝트라고 부르는 것의 개념은 정말 단순합니다. 프로젝트는 특정한 작업을 할 때는 항상 사용하기로 미리 정해놓은 폴더 그 이상도 이하도 아닙니다. 예컨대, 지금 저는 이 교재를 쓰기 위해 Rstudio를 사용하고 있는데요, 이 교과서를 쓸 때는 Book이라는 프로젝트를 만들고, 해당 폴더 안에 책의 원고, 코드, 데이터 등을 모두 저장해 둡니다. 교과서를 쓰기 위해 필요한 모든 자료를 하나의 폴더 안에 모두 저장해 두고, Rstudio에게 “난 이 교재를 쓸 때는 Book 폴더만 사용할거야”, 라고 미리 말해두기만 하면, Rstudio에게 “나 이제부터 교재 쓴다”라고 알려주면 Rstudio는 알아서 작업경로를 바꿔줍니다.\n물론 저는 이 교재를 쓸 때 말고도, 다양한 이유로 Rstudio를 사용합니다. 예컨대 어떤 연구를 위해 Research라는 프로젝트를 만들어 두었다고 해 보죠. 그러면 Rstudio에게 “나 이제부터 연구한다” 라고 말해주면 Rstudio는 Research 폴더로 작업 경로를 바꿔줍니다. 그러면 교과서를 쓰다가 연구를 하다가 반복한다고 하더라도 작업경로 때문에 골치아픈 에러를 겪을 일이 없어지겠지요. 여러 개의 기획 기사를 동시에 쓰는 상황이라면, 기사1, 기사2, 기사3에 대한 프로젝트를 따로 만들어 두고 해당 기사를 작성할 때는 해당 프로젝트 안에서 활동하면 헷갈릴 일이 없습니다.\n이렇게만 이야기하면, 프로젝트가 큰 쓸모가 없어보이지만, 동시에 하는 작업의 종류가 늘어날 수록 경로로 인해 발생하는 에러의 빈도는 그야말로 ’기하급수’적으로 늘어납니다. Rstudio의 기능 중에 프로젝트 보다 에러를 줄여주는 기능은 없다고 감히 단언할 수 있으니, R을 처음 배우는 지금부터 꼭 프로젝트를 사용하는 버릇을 들이길 바랍니다.\n그러면, 프로젝트를 어떻게 만들고, 어떻게 프로젝트 사이를 이동하는지를 살펴보겠습니다.\n\n새 프로젝트 만들기\n새 프로젝트를 만드는 방법은 간단합니다. Rstudio의 File 메뉴를 선택해보세요. 그러면 드롭다운 메뉴에서 New Proejct라는 기능을 찾을 수 있습니다. 이를 누르면, 다음과 같은 화면이 등장할 것입니다.\n\n\n\n새 프로젝트\n\n\n여기서 프로젝트 명은 새로 만들어질 폴더의 이름이고, 경로는 그 폴더가 만들어질 상위 폴더라고 생각하시면 됩니다. 예컨대 위의 예에서, 저는 Spring2023 폴더 아래 Book이라는 새로운 폴더를 만들어 바로 그 폴더를 프로젝트 폴더로 사용하려는 것이지요.\nOK를 누르고 나면, 몇 초에 걸쳐 프로젝터(=폴더)가 만들어집니다. 프로젝트가 폴더에 불과하다는 것을 확인하기 위해서 해당 폴더를 찾아보지요. 저는 지금 윈도우를 이용하고 있기 때문에 탐색기를 이용하겠습니다.\n\n\n\n폴더에서 프로젝트 찾기\n\n\n새로 폴더가 하나 만들어져 있지요? 그 안에는 Book.Rproj라는 파일도 자동으로 만들어져 있는데, 이 파일은 단지 이 폴더가 그냥 폴더가 아니고 R을 이용한 프로젝트를 수행하기 위한 폴더임을 표시하는 것입니다. 이것은 조금 있다가 서로 다른 폴더 사이를 이동할 때 이용할 것입니다. 자, 이제 우리는 이제 책을 쓰기 위해서는 이 폴더만 사용하게 될 것입니다. 새로 작성한 코드도, 사용할 데이터도 이 폴더 안에 모두 저장하는 것이지요.\n\n\n프로젝트 바꾸기\n그런데 이미 복수의 프로젝트를 가지고 있었다면, 프로젝트 사이는 어떻게 왔다갔다 할 수 있을까요? 간단합니다. 다시 File 메뉴를 선택해 보세요. 그러면 Open Project라는 기능이 있을 것입니다. 이것을 선택하면, 일반 탐색기처럼 폴더를 선택할 수 있습니다. 만약 Research라는 프로젝트로 이동하고 싶다고 해당 프로젝트 폴더를 찾아가면 됩니다. Research 프로젝트가 이미 만들어져 있었다면 해당 폴더에는 Research.Rproj라는 파일이 저장되어 있겠지요. 그 파일을 선택한 후, OK를 누르면 이제 Rstudio는 Research 프로젝트로 이동합니다. 이제 저는 연구를 하는 것입니다.\n\n\n\n새로운 프로젝트로 이동\n\n\n그런데, 사실 이렇게 복잡한 방식으로 프로젝트 사이를 이동하는 경우는 많지 않습니다. 더 간단한 방법이 있거든요. 아까 이용한 Open Project 메뉴 아래에는 Recent Projects라는 메뉴도 있습니다. 그 위에 마우스 포인트를 올리면 최근에 이용한 프로젝트의 목록이 나타납니다. 그 목록 중 내가 이동하고 싶은 프로젝트를 클릭하면, 아주 간단하게 프로젝트 사이를 이동할 수 있습니다.\n이제 여러분이 Rstudio를 켜고 작업을 하려고 할 때 처음으로 해야 할 일은 적절한 프로젝트를 이용하는 것입니다. 새로운 작업을 시작한다면? 프로젝트를 만드세요. 만약 프로젝트를 이미 만들어 놓은 작업을 계속하고 싶다면? 지금 Rstudio가 그 작업에 해당하는 프로젝트를 이용하고 있는지 확인하세요. 만약 그렇지 않다면 Recent Projects나 Open Project를 이용해 해당 프로젝트로 이동하면 됩니다. 항상 작업은 그 이후에 시작합니다."
  },
  {
    "objectID": "5_basic.html#quarto-노트북",
    "href": "5_basic.html#quarto-노트북",
    "title": "R의 기초",
    "section": "Quarto 노트북",
    "text": "Quarto 노트북\n우리는 지금까지 R의 기초적인 기능을 살펴보면서, 콘솔이라고 하는 창을 이용해 왔습니다. 이 콘솔이라고 하는 창은 R의 엔진, 실제로 프로그램이 돌아가는 곳이라고 볼 수 있습니다. 하지만 콘솔에서는 코드를 작성하고 엔터키를 누르는 순간, 프로그램이 실행되고 맙니다. 지금까지 작성해 온 간단한 코드라면, 이런 방식으로 충분하겠지만, 만약 수십줄, 많게는 수백줄의 코드를 작성하고, 작성한 코드가 한 번에 실행되기를 바란다면, 이것은 그다지 효율적인 방법이 아니겠지요. 따라서, 대부분 프로그래머들은 컴퓨터 메모장에 글을 쓰듯, 먼저 긴 코드를 작성한 후, 이것이 차례차례 콘솔에서 작동되도록 합니다. 이를 위해 작성한 코드로 이루어진 텍스트 파일을 흔히 ’스크립트’라고 부릅니다. 하지만 이런 스크립트 방식의코드 작성법은 콘솔을 이용한 방법과는 반대로 작성한 코드의 부분부분이 의도한대로 잘 작동하는지 확인하는 것을 어렵게 만듭니다.\n따라서, 우리는 그 중간쯤 되는 ’노트북’이라는 방법을 사용하려고 합니다. 노트북 방법을 사용하면, 코드를 작성하면서 중간중간 결과를 확인할 수도 있고, 프로그램을 모두 작성한 후에는 전체 프로그램을 한 번에 실행할 수도 있습니다. 그리고 그보다 더 좋은 점은 코드와 코드 사이 원하는대로 문서를 작성할 수도 있고, 그 결과를 그대로 문서 파일, 프리젠테이션 파일, 심지어 웹페이지 형태로 바로 추출할 수 있다는 점입니다. 온라인 기사를 작성한다고 생각해 보면, 데이터 분석, 시각화, 기사 작성을 한 문서 안에서 별도의 작업 없이 할 수 있다는 뜻입니다! 따라서, 이 교재에서는 내내 노트북 환경을 사용하도록 하하겠습니다."
  },
  {
    "objectID": "5_basic.html#노트북-생성하기",
    "href": "5_basic.html#노트북-생성하기",
    "title": "R의 기초",
    "section": "노트북 생성하기",
    "text": "노트북 생성하기\n노트북 환경을 이용하는 방법은 여러가지가 있지만, 우리는 “Quarto Document”라는 가장 표준적인 방법을 사용할 것입니다. “Quarto Document”를 사용하려면 새로운 “Quarto Document” 파일을 하나 만들어주면 됩니다. Rstudio 상단의 File 메뉴에서 New File이라고 되어 있는 곳에 마우스 커서를 올려보세요, 그러면 오른쪽에 떠오르는 메뉴에 “Quarto Document”라는 항목이 있을 것입니다. 이를 클릭하면 다음과 같은 창이 떠오릅니다.\n\n\n\nQuarto Document 만들기\n\n\n여기서 지시하는대로 문서의 제목, 작성자(Author)의 이름 등을 입력하세요. 그러면, 파일 하나가 생성됩니다.\n그 다음 Visual이라고 되어 있는 모드를 Source로 바꿔주세요. (Visual 모드를 사용해도 되지만, 우리는 Source 모드를 이용하겠습니다.)\n\n\n\nSource 모드로 전환\n\n\n마지막으로 해당 파일을 저장해 주세요. ‘File’ 메뉴에서 ’Save’를 클릭한 후, 파일명을 정해주면 됩니다. 확장자는 qmd가 됩니다.\n이제 여러분은 노트북 환경을 이용하기 위한 준비가 되었습니다."
  },
  {
    "objectID": "5_basic.html#노트북-이용하기",
    "href": "5_basic.html#노트북-이용하기",
    "title": "R의 기초",
    "section": "노트북 이용하기",
    "text": "노트북 이용하기\n노트북 환경은 구체적으로는 다음과 같습니다.\n\n\n\n노트북 환경\n\n\n이 노트북 환경은 크게 세 부분으로 이루어집니다. 첫번째, ---로 둘러싸여 저자, 제목 등의 정보를 제공하는 부분입니다. 이는 YAML header라고 부르는데요, 꼭 있어야 하는 부분은 아닙니다. 하지만 조금 후에 굉장히 유용해 질 것이므로, 그대로 이용하실 것을 권장합니다. 제목(title)이나, 저자(author)의 내용에 해당하는 부분은 원하는대로 바꾸어도 좋습니다.\n두번째 부분은 코드가 쓰여지는 chunk라고 부르는 부분입니다. chunk는 세 개의 “backtick”, 즉 “역따옴표”로 코드를 둘러싸서 표현합니다. 역따옴표에 익숙지 않다면, 키도드 숫자 1 왼쪽에 있는 키가 역따옴표를 사용하기 위한 키 입니다. 여러분들은 주로 shift 키와 함께 물결 표시를 사용하기 위해 더 자주 사용했을 것입니다. Rstudio는 세 개의 역따옴표 있는 문자를 모두 프로그래밍 코드라고 인식합니다.\n특히, 시작하는 세 개의 역따옴표 옆에 {r}이라고 쓰게되면, 이제 Rstudio는 해당 chunk 안의 모든 문자를 다른 프로그램도 아닌 R 문법으로 작성한 코드라고 생각합니다. 만약, chunk 안에서 R 문법에 어긋나는 문자가 있다면 에러가 발생하게 될 것입니다.\n역따옴표와 사용할 프로그램을 표시하여 (예컨대, ```{r}이라고 표시하여) R 코드임이 명확해지면, Rstudio는 chunk가 시작하는 줄 오른쪽에 작은 플레이 버튼 같은 것을 표시합니다. 이 버튼을 클릭해 보세요. 그러면 해당 chunk에 쓴 R 코드가 실행되고, 그 결과는 해당 코드 바로 밑에 표시됩니다. 이런 식으로 스크립트를 작성하면서, 즉시 콘솔에서처럼 결과도 확인할 수 있게 되는 것이지요.\n마지막 부분은 앞의 두 요소 밖에 있는 모든 문자들 입니다. 이는 물론 일반 텍스트를 뜻합니다. 이 부분은 글을 쓰듯 자유롭게 작성하면 됩니다. 사실 아무 것도 아닌 것 같지만, 이렇게 내가 쓰고 싶은 글과 R 코드, 그리고 R 코드의 결과물까지 하나의 텍스트 파일 위에서 표현할 수 있게 됩니다. 마치 다음 그림 처럼요.\n\n\n\n노트북 환경\n\n\n마치 하나의 웹페이지 화면처럼 보이지 않나요? 실제로 텍스트 파일 상단에 있는 Render 버튼을 누르기만 하면 바로 웹페이지를 만들어냅니다. 더 정확하게는 해당 qmd파일을 일종의 스크립트 삼아, 텍스트 부분은 텍스트로 표현하고, chunk에 해당하는 부분은 코드를 실행시킨 다음, 그 결과까지 모두 포함하여 하나의 HTML 파일을 만들어 냅니다. 여러분이 사용하고 있는 프로젝트 폴더에 들어가보세요. 방금 Render한 qmd파일과 같은 파일명을 가진 HTML 파일이 생성되어 있을 것입니다. 그 파일을 더블클릭하면, 여러분이 사용하는 브라우저를 통해 마치 웹페이지처럼 정돈된 결과물을 볼 수 있습니다.\n방금 Render한 qmd 파일에서 일반 텍스트가 여러분이 작성한 기사 내용, 그리고 chunk가 여러분이 독자들에게 보이고자 하는 데이터 시각화를 시행하는 코드라고 생각해 보세요! 그러면 여러분은 이미 인터넷으로 배포할 수 있는 기사 웹페이지 하나를 만든 셈입니다!"
  },
  {
    "objectID": "5_basic.html#마크다운-문법",
    "href": "5_basic.html#마크다운-문법",
    "title": "R의 기초",
    "section": "마크다운 문법",
    "text": "마크다운 문법\nRstudio가 우리가 작성한 qmd 파일에서 코드에 해당하는 부분, 일반 텍스트에 해당하는 부분을 자동으로 구분하고 다양한 기능을 사용할 수 있게 해줄 뿐만 아니라, 심지어 웹페이지로까지 만들어 주는 것은 우리가 Rstudio가 이해할 수 있는 특정 문법을 따르기 때문입니다. 이 문법을 ’마크다운(markdown)’이라고 부릅니다. 사실 확장자명 qmd에서 “md”가 마크다운(markdown)을 뜻하지요. 앞서 사용한 “—” “```{r}” 이런 것들이 마크다운 문법 중 일부입니다. 마크다운의 문법은 물론 이것 말고도 다양합니다.\n우리는 앞서 Rstudio가 chunk 안에 있는 문자는 코드로 인식해 실행하고, 그 밖의 문자는 텍스트 그대로 표현한다고 했습니다. 사실 이는 정확한 이야기가 아닙니다. 왜냐하면 Rstudio가 chunk 밖의 문자를 일반 텍스트로 인식하는 것은 맞지만, 일반 텍스트에 여러 효과를 부여하기 위한 몇 가지 간단한 문법이 있기 때문이지요. 이러한 문법들은 써도 그만, 안 써도 그만이지만 시각적으로 더 효율적인 웹페이지를 생성하기 위해 유용합니다. 예컨대 다음과 같은 것들이 그 문법에 해당합니다.\n\n글씨체\n*기울임 *\n**굵게**\n~~취소선~~\n`코드`\n# 최상위 제목\n## 2단계 제목\n### 3단계 제목\n나열하기\n- 아이템1\n- 아이템2\n- 아이템 2a\n- 아이템 2b\n\nNumbered list item 1\nItem 2. The numbers are incremented automatically in the output.\n\n링크와 그림\n&lt;http://example.com&gt;\n[linked phrase](http://example.com)\n테이블\n| First Header | Second Header |\n|————–|—————|\n| Content Cell | Content Cell |\n| Content Cell | Content Cell |\n\n이러한 문법들은 Render 버튼을 누르면 웹페이지를 위한 적절한 시각 요소로 번역됩니다. 위의 문법 말고도 정말 다양하면서도 간단한 문법들이 있는데요, 여기서 모두 설명할 수는 없으니, Rstudio 노트북을 가능하게 해 주는 기반 기술인 Quarto 홈페이지에서 마크다운 문법을 자세히 설명한 웹사이트를 참조하는 것을 가장 권장합니다. 대신 이곳의 설명이 영어로 되어 있기 때문에, 이를 꺼리시는 분들은 검색창에서 ’Quarto 마크다운 문법’이라고 치시면 많은 한글 자료를 보실 수 있을 것입니다.\n이제 간단한 마크다운 문법을 알면 이용자는 HTML 같이 복잡한 마크업 문법을 몰라도 웹페이지를 간단하게 만들 수 있습니다. Rstudio가 내장하고 있는 프로그램이 마크다운 문서를 HTML로 다시 재번역해 주거든요(그것이 여러분이 Rstudio에서 이용하는 Render 버튼의 의미입니다). 여러분들이 매일 이용하는 웹브라우저는 이렇게 번역된 HTML을 이해할 수 있으니 여러분은 뉴스 작성을 위해 HTML을 따로 공부할 필요가 없습니다.\n\n\n\nRstudio가 마크다운을 웹페이지로 만드는 순서\n\n\n명심하세요! 여러분들은 이 책을 통해 연습을 하는 동안 항상 qmd 파일을 하나 만들어 마크다운 문법을 이요해 코드와 텍스트를 동시에 작성하고 이를 HTML로 렌더하는 작업을 반복할 것입니다. 그 외에도 R을 사용하는 여러 방법이 있지만, 일단 가장 쉽고 기사 작성을 위해 유용한 이 방법을 반복해서 사용하세요!"
  },
  {
    "objectID": "3_tidygraph.html",
    "href": "3_tidygraph.html",
    "title": "Tidy한 네트워크 분석",
    "section": "",
    "text": "library(tidyverse)\nlibrary(purrr)\nlibrary(tidytext)\nlibrary(tidygraph)\nlibrary(igraph)\nlibrary(networkD3)\nlibrary(widyr)\nlibrary(ggraph)\nlibrary(glue)\nlibrary(showtext)\nfont_add_google(name = \"Nanum Gothic\", family = \"nanumgothic\")\nshowtext_auto()\n\n\n\n테그 레퍼런스: https://aiopen.etri.re.kr/guide/WiseNLU\n\ndt_ner |&gt;\n    filter(!str_detect(type, \"DT_|QT_|AM_|TI_|MT_|PT_\")) |&gt;\n        #!(type %in% c(\"\")))\n    count(text, sort=T)\n\n\ndt_cat &lt;- dt_ner |&gt; \n    filter(str_detect(type, \"(^PS_NAME)|^(LC)|^(OG)\")) |&gt;\n    mutate(cat = case_when(str_detect(type, \"^PS_NAME\") ~  \"인물\",\n                           str_detect(type, \"^LC\") ~ \"장소\",\n                           str_detect(type, \"^OG\") ~ \"조직\"))\n\n\nnodeAttr &lt;- dt_cat |&gt;\n    group_by(text, cat) |&gt;\n    summarise(text=first(text), cat=first(cat)) |&gt;\n    ungroup()\n\n\n#saveRDS(nodeAttr, \"nodeAttr.rds\")\n\n\ndupList &lt;- nodeAttr |&gt;\n    group_by(text) |&gt;\n    summarise(n = n()) |&gt;\n    filter(n &gt;= 2) |&gt;\n    pull(text)\n\n\n#saveRDS(dupList, \"dupList.rds\")\n\n\nnodeAttr |&gt;\n    filter(text %in% dupList)\n\n\n\n\n\ng &lt;- dt_cat |&gt;\n    filter(!(text %in% dupList)) |&gt;\n    unite(\"bp\", c(\"book\", \"para\")) |&gt;\n    pairwise_count(text, bp, sort=TRUE, diag=FALSE) |&gt;\n    rename(weight=n) |&gt;\n    #filter(weight &gt; 5) |&gt;\n    graph_from_data_frame(directed=FALSE)\n\n\nis_weighted(g)\n\n\ngTidy &lt;- g |&gt;\n    as_tbl_graph()\n\n\nsaveRDS(gTidy, \"gTidy.rds\")\n\n\n\n\n\n#nodeList &lt;- gTidy |&gt;\n#    activate(nodes) |&gt;\n#    pull()\n\n\ngTidy |&gt; \n    activate(edges) |&gt;\n    filter(weight &gt; 4) |&gt;\n    activate(nodes) |&gt; \n    left_join(nodeAttr |&gt;\n                  filter(!(text %in% dupList)), by=c(\"name\"=\"text\")) |&gt;\n    mutate(degree = centrality_degree()) |&gt;\n    filter(degree != 0) |&gt;\n    ggraph() +\n    aes(edgh_width=weight, alpah=weight) +\n    geom_edge_link(alpha = 0.50, edge_color = \"grey20\") +\n    geom_node_point(aes(color=cat), size=10) +\n  #  geom_node_text(aes(label=name)) |&gt;\n    geom_node_text(aes(label = name),         # 텍스트 표시\n                 repel = T,                 # 노드밖 표시\n                 size = 5,                  # 텍스트 크기\n                 family = \"nanumgothic\") +  # 폰트\n  theme_graph()                             # 배경 삭제                       # 배경 삭제\n\n\npair &lt;- dt_ner |&gt;\n    filter(!str_detect(type, \"DT_|QT_|AM_|TI_|MT_|PT_\")) |&gt;\n    pairwise_count(item = text, \n                   feature = para,    # 다른 책의 같은 para일 수 있음 -&gt; book도 같이 구분하도록 고쳐야 함!\n                   sort = T)\n\n\npair |&gt;\n    filter(item1 == \"조선족\")\n\n\ngraph_kd &lt;- pair %&gt;%\n  filter(n &gt;= 10) %&gt;%\n  as_tbl_graph(directed = F) %&gt;%\n  mutate(centrality = centrality_degree(),    # 연결 중심성\n         group = as.factor(group_infomap()))  # 커뮤니티\n\n\ngraph_kd |&gt;\n    ggraph(layout = \"fr\") +      # 레이아웃\n  geom_edge_link(color = \"gray50\",          # 엣지 색깔\n                 alpha = 0.5) +             # 엣지 명암\n  geom_node_point(aes(size = centrality,    # 노드 크기\n                      color = group),       # 노드 색깔\n                  show.legend = F) +        # 범례 삭제\n  scale_size(range = c(5, 15)) +            # 노드 크기 범위\n  geom_node_text(aes(label = name),         # 텍스트 표시\n                 repel = T,                 # 노드밖 표시\n                 size = 5,                  # 텍스트 크기\n                 family = \"nanumgothic\") +  # 폰트\n  theme_graph()                             # 배경 삭제\n\nhttps://youngwoos.github.io/Doit_textmining/05/05-co-occurrenceAnalysis.html#90\n\n\n\n\ngig &lt;- gTidy |&gt; \n    activate(edges) |&gt;\n    filter(weight &gt; 4) |&gt;\n    activate(nodes) |&gt; \n    left_join(nodeAttr |&gt;\n                  filter(!(text %in% dupList)), by=c(\"name\"=\"text\")) |&gt;\n    mutate(degree = centrality_degree()) |&gt;\n    filter(degree != 0) |&gt;\n    as.igraph() \ngD3 &lt;- gig |&gt;\n    igraph_to_networkD3(group=vertex_attr(gig)$cat)\n\n\nforceNetwork(Links=gD3$links, Nodes=gD3$nodes,\n             Source = 'source', Target = 'target', NodeID = 'name', Group = 'group')"
  },
  {
    "objectID": "3_tidygraph.html#ner-테그를-이용해-인물-장소-조직을-추출",
    "href": "3_tidygraph.html#ner-테그를-이용해-인물-장소-조직을-추출",
    "title": "Tidy한 네트워크 분석",
    "section": "",
    "text": "테그 레퍼런스: https://aiopen.etri.re.kr/guide/WiseNLU\n\ndt_ner |&gt;\n    filter(!str_detect(type, \"DT_|QT_|AM_|TI_|MT_|PT_\")) |&gt;\n        #!(type %in% c(\"\")))\n    count(text, sort=T)\n\n\ndt_cat &lt;- dt_ner |&gt; \n    filter(str_detect(type, \"(^PS_NAME)|^(LC)|^(OG)\")) |&gt;\n    mutate(cat = case_when(str_detect(type, \"^PS_NAME\") ~  \"인물\",\n                           str_detect(type, \"^LC\") ~ \"장소\",\n                           str_detect(type, \"^OG\") ~ \"조직\"))\n\n\nnodeAttr &lt;- dt_cat |&gt;\n    group_by(text, cat) |&gt;\n    summarise(text=first(text), cat=first(cat)) |&gt;\n    ungroup()\n\n\n#saveRDS(nodeAttr, \"nodeAttr.rds\")\n\n\ndupList &lt;- nodeAttr |&gt;\n    group_by(text) |&gt;\n    summarise(n = n()) |&gt;\n    filter(n &gt;= 2) |&gt;\n    pull(text)\n\n\n#saveRDS(dupList, \"dupList.rds\")\n\n\nnodeAttr |&gt;\n    filter(text %in% dupList)"
  },
  {
    "objectID": "3_tidygraph.html#그래프-데이터로-변환환",
    "href": "3_tidygraph.html#그래프-데이터로-변환환",
    "title": "Tidy한 네트워크 분석",
    "section": "",
    "text": "g &lt;- dt_cat |&gt;\n    filter(!(text %in% dupList)) |&gt;\n    unite(\"bp\", c(\"book\", \"para\")) |&gt;\n    pairwise_count(text, bp, sort=TRUE, diag=FALSE) |&gt;\n    rename(weight=n) |&gt;\n    #filter(weight &gt; 5) |&gt;\n    graph_from_data_frame(directed=FALSE)\n\n\nis_weighted(g)\n\n\ngTidy &lt;- g |&gt;\n    as_tbl_graph()\n\n\nsaveRDS(gTidy, \"gTidy.rds\")"
  },
  {
    "objectID": "3_tidygraph.html#그래프-시각화",
    "href": "3_tidygraph.html#그래프-시각화",
    "title": "Tidy한 네트워크 분석",
    "section": "",
    "text": "#nodeList &lt;- gTidy |&gt;\n#    activate(nodes) |&gt;\n#    pull()\n\n\ngTidy |&gt; \n    activate(edges) |&gt;\n    filter(weight &gt; 4) |&gt;\n    activate(nodes) |&gt; \n    left_join(nodeAttr |&gt;\n                  filter(!(text %in% dupList)), by=c(\"name\"=\"text\")) |&gt;\n    mutate(degree = centrality_degree()) |&gt;\n    filter(degree != 0) |&gt;\n    ggraph() +\n    aes(edgh_width=weight, alpah=weight) +\n    geom_edge_link(alpha = 0.50, edge_color = \"grey20\") +\n    geom_node_point(aes(color=cat), size=10) +\n  #  geom_node_text(aes(label=name)) |&gt;\n    geom_node_text(aes(label = name),         # 텍스트 표시\n                 repel = T,                 # 노드밖 표시\n                 size = 5,                  # 텍스트 크기\n                 family = \"nanumgothic\") +  # 폰트\n  theme_graph()                             # 배경 삭제                       # 배경 삭제\n\n\npair &lt;- dt_ner |&gt;\n    filter(!str_detect(type, \"DT_|QT_|AM_|TI_|MT_|PT_\")) |&gt;\n    pairwise_count(item = text, \n                   feature = para,    # 다른 책의 같은 para일 수 있음 -&gt; book도 같이 구분하도록 고쳐야 함!\n                   sort = T)\n\n\npair |&gt;\n    filter(item1 == \"조선족\")\n\n\ngraph_kd &lt;- pair %&gt;%\n  filter(n &gt;= 10) %&gt;%\n  as_tbl_graph(directed = F) %&gt;%\n  mutate(centrality = centrality_degree(),    # 연결 중심성\n         group = as.factor(group_infomap()))  # 커뮤니티\n\n\ngraph_kd |&gt;\n    ggraph(layout = \"fr\") +      # 레이아웃\n  geom_edge_link(color = \"gray50\",          # 엣지 색깔\n                 alpha = 0.5) +             # 엣지 명암\n  geom_node_point(aes(size = centrality,    # 노드 크기\n                      color = group),       # 노드 색깔\n                  show.legend = F) +        # 범례 삭제\n  scale_size(range = c(5, 15)) +            # 노드 크기 범위\n  geom_node_text(aes(label = name),         # 텍스트 표시\n                 repel = T,                 # 노드밖 표시\n                 size = 5,                  # 텍스트 크기\n                 family = \"nanumgothic\") +  # 폰트\n  theme_graph()                             # 배경 삭제\n\nhttps://youngwoos.github.io/Doit_textmining/05/05-co-occurrenceAnalysis.html#90"
  },
  {
    "objectID": "3_tidygraph.html#networkd3를-이용한-인터랙리브-시각화",
    "href": "3_tidygraph.html#networkd3를-이용한-인터랙리브-시각화",
    "title": "Tidy한 네트워크 분석",
    "section": "",
    "text": "gig &lt;- gTidy |&gt; \n    activate(edges) |&gt;\n    filter(weight &gt; 4) |&gt;\n    activate(nodes) |&gt; \n    left_join(nodeAttr |&gt;\n                  filter(!(text %in% dupList)), by=c(\"name\"=\"text\")) |&gt;\n    mutate(degree = centrality_degree()) |&gt;\n    filter(degree != 0) |&gt;\n    as.igraph() \ngD3 &lt;- gig |&gt;\n    igraph_to_networkD3(group=vertex_attr(gig)$cat)\n\n\nforceNetwork(Links=gD3$links, Nodes=gD3$nodes,\n             Source = 'source', Target = 'target', NodeID = 'name', Group = 'group')"
  },
  {
    "objectID": "1_prerequisite.html",
    "href": "1_prerequisite.html",
    "title": "강의 사전 준비",
    "section": "",
    "text": "본 튜토리얼에서는 강의를 듣기 앞서 필수적으로 이루어져야 하는 사전 준비작업들을 설명합니다. 수강자분들께서는 수강 전에 반드시 여기서 설명된 준비 작업을 수행하시고, 강의에 참여해주시기 바랍니다. 한정된 강의 시간과 수강생의 수를 고려할 때 강의 중 아래 준비작업에 도움을 드리기는 어렵다는 점 기억해 주시기 바랍니다. R을 이용해 본 경험이 있는 분들은 아래 체크리스트를 살펴 보시고 아직 이루어지지 않은 부분만 실행하시면 되겠습니다.\n\n\n\nR 설치\nRtools 설치 (윈도우즈 이용자만)\nRstudio 설치\ntidyverse 등 패키지 설치\nKoNLP 설치\nETRI AI API 받기\nKODDAS API 작동 체크\n사전 설문조사 참여\n\n만약, 위의 사전 작업을 수행하시는 중에 해결이 안 되는 부분이 있다면, 다음 오픈채팅방을 이용해서 질문해주시기 바랍니다. 다만, 튜토리얼을 상세히 읽고, 혼자 최대한 시도를 해 보고 질문을 해 주실 것을 부탁드립니다. 오픈채팅 방은 강의 중에도 사용될 예정이나, 모두 가입해주시면 감사하겠습니다.\n\n오픈 카톡\n\n또한, 당일 원활한 워크샵 진행을 위해 사전 설문조사를 꼭 작성해 주시기 바랍니다. 참여자 분들이 이미 익숙한 내용에 대한 반복을 피하고, 가능한 모두에게 유용한 내용의 워크샵이 될 수 있도록 준비하기 위함입니다.\n\n사전 설문조사\n\n가장 먼저 본 워크샵의 작업 환경에 해당하는 R과 Rstudio의 설치법을 설명합니다. 실제로 이용하는 언어는 R이지만, R 그 자체는 편리한 사용성을 제공하지 못합니다. 하지만, R이 이미 설치되어 있다면, Rstudio를 통해서 훨씬 편하고 세련된 환경에서 코딩을 할 수 있을 뿐만 아니라 R 자체로는 구현할 수 없는 중요한 추가적인 기능들–홈페이지 제작, 인터렉티브 시각화 등–을 활욯할 수 있게 됩니다. 따라서, 본 교재의 학습을 위해서는 R과 Rstudio 모두를 설치해야 합니다.\n\n\n\nR을 설치하기 위해서는 R다운로드 페이지로 이동해야 합니다.\n\n\n\nR 다운로드 페이지\n\n\n여기에서 사용하는 운영체제에 맞추어 링크를 선택합니다. 여기서는 윈도우즈 사용환경을 가정하고 ’Download R for Windows’를 클릭합니다 (물론 맥 이용자나 리눅스 이용자라면 다른 옵션을 선택하시면 됩니다). 그러면 다음과 같은 화면이 나타날 것입니다.\n 윈도우즈 이용자들은 두 가지를 설치해야 합니다. 하나는 ’base’라고 표시되어 있는 R프로그램 그 자체입니다. 해당 하이퍼링크를 클릭하면 이동하는 페이지에 ’Download R-4.4.2 for Windows’라고 표시된 하이퍼링크가 있을 것입니다 (4.4.2이라는 버전을 나타내는 숫자는 최신 업데이트에 따라 달라질 수 있습니다). 이를 클릭하면 다음 설치 파일이 다운로드 됩니다.\n두번째로 다운로드 받을 파일은 위의 화면 캡춰에서 Rtools라고 표시되어 있는 R의 확장 프로그램 입니다. 이 역시 R의 다양한 기능을 활용하기 위해서 반드시 필요합니다. 해당 링크를 클릭하여 앞서 다운 받은 R 버전에 맞는 RTools를 다운받습니다. 예컨대 앞서 R 4.4.0버전을 다운 받았으니, ’RTools 4.4’을 다운받는 것이지요.\n\n\n\n\n\n\nNote\n\n\n\n윈도우즈 사용자는 반드시 R과 RTools 모두를 설치해야 합니다. RTools를 설치하지 않은 경우, 뒤에서 설명할 여러 패키지 설치 과정이 작동하지 않을 수 있습니다.\n단, 맥 사용자는 R만 설치하면 됩니다.\n\n\n이제 두 설치파일을 다운로드 받은 순서대로 더블클릭하여 설치를 완료하면 됩니다. 여기서도, 한 가지 주의사항이 있습니다. R은 오픈소스 언어이기 때문에, 상업 프로그램처럼 다양한 언어를 부드럽게 처리하지못하는 경우가 있습니다. 관련해서 가장 많은 에러를 양산하는 문제 중 하나가 R이 설치된 경로상에 한글이 섞여 있는 경우 입니다. 예컨대, 윈도우즈의 이용자 이름이 자신의 이름으로 되어 있다면, 설치경로가 에러를 만들어 내는 경우가 많습니다. 예컨대, “C:.2”과 같은 주소는 한글이 포함되어 좋지 않다는 이야기 입니다. “C:Files.2”과 같은 설치 경로는 한글이 포함되어 있지 않으므로, 문제가 없습니다. 따라서, 윈도우즈 이용자 이름에 알파벳이 아닌 다른 문자가 섞여 있다면, R 설치시 설정하는 모든 경로를 이용자 이름이 섞이지 않도록 적절하게 수정해 주는 것이 좋습니다.\n\n\n\n\n\n\nNote\n\n\n\nR 설치 경로는 알파벳만으로 이루어지도록 주의하세요.\n\n\n\n\n\nRstudio는 오픈소스 프로젝트가 아니라 사기업인 Posit에 의해 관리되기 때문에 다운로드 및 설치가 더욱 쉽습니다. 다음 링크를 따라가서, 각자의 운영체제에 맞는 설치파일을 다운 받은 후 실행해 주면 됩니다. 다만, Rstuio의 설치는 R 설치가 모두 완료된 다음 해 주는 것이 불필요한 에러를 방지할 수 있습니다.\n\n\n\nRstudio 다운로드 페이지\n\n\n\n\n\n먼저, R은 윈도우 시작 버튼을 눌러 실행할 수 있습니다. 시작 화면에서 전체 애플리케이션을 열면, 여러분의 컴퓨터에 설치된R은 보통 다음과 같이 나타납니다.\n\n\n\n윈도우즈에서 R 실행하기\n\n\n제 경우에는 여러 버전의 R을 설치하다보니 여러 가지의 R이 보이는데요, 그 중에서 버전이 가장 높은 것을 선택하시면 됩니다. i386과 x64는 여러분이 사용하는 컴퓨터의 환경과 관련이 있는데, 대부분의 요즘 컴퓨터는 x64라고 생각하시면 됩니다. 따라서 위의 경우에는 R x64 4.1.3을 선택하면 되겠네요. 이를 실행하면 다음과 같은 화면이 나타나게 됩니다.\n\n\n\nR 화면\n\n\n화면에 가장 크게 보이는 하얀 창이 바로 R의 핵심인 콘솔(Console) 입니다. 여기에 이러저러한 명령을 하고 엔터를 치면 R은 해당 명령을 수행한 결과를 표시해 줍니다. R을 사용하는 가장 단순한 방법은 계산기 처럼 활용하는 것입니다. 예컨대 2+1이라는 연산을 한다고 해 볼까요? 그 때는 가장 단순하게 다음과 2+1이라고 콘솔에 쓰시고 엔터키를 치면 됩니다. 그러면 다음과 같은 결과를 볼 것입니다.\n\n2+1\n\n[1] 3\n\n\n물론, 여러분이 나중에 작성하게될 코드는 이보다 복잡할 것입니다. 그렇다면 코드를 한줄 쓰고 실행하는 이런 단순한 방식은 아무래도 불편할 것입니다. 따라서, 대부분의 이용자들은 위와 같은 화면에서 R을 사용하지 않습니다. 대신 Rstudio라는 환경을 사용하지요.\n여러분 컴퓨터에 설치된 Rstudio를 사용하는 가장 간단한 방법은 윈도우즈 화면 하단 시작 버튼 옆의 검색창에 ’Rstudio’라고 검색해 보는 것입니다. Rstudio가 올바르게 설치되어 있다면, 다음과 유사한 화면을 보게 될 것입니다.\n\n\n\nRstudio 시작\n\n\n이제 Rstudio를 선택해서 프로그램을 실행시키면 다음과 같은 화면이 나타납니다.\n\n\n\nRstudio 첫 화면\n\n\n바탕화면은 초기설정에 따라 위와 같이 어두운 색이기도, 밝은 색이기도 합니다. Rstudio는 R을 편리하게 사용할 수 있도록 도와줄 뿐만 아니라, R의 더 많은 기능을 이끌어내기 위해 만들어낸 인터페이스라고 생각하시면 됩니다. 전문적인 용어로는 통합개발환경(IDE)라고 하지요. 비유하자면, R가 엔진이라면, Rstudio는 여러분이 직접 운전하는 자동차와 같은 관계라고 생각하시면 되겠습니다. 엔진을 이용해 직접 가능한 탈것을 만드는 사람은 극히 제한적이듯, 대부분의 사람들은 Rstudio를 사용하지, R을 직접 사용하지 않습니다. 따라서, 여러분들 역시 앞으로 Rstudio만을 사용하게 될 것입니다.\n\n\n\nR과 Rstudio 간의 관계\n\n\nRstudio의 초기 화면에 보이는 가장 큰 공간은 R의 콘솔 입니다. 앞서 R의 기본 인터페이스에서 본 콘솔과 같은 콘솔이지요. 따라서 앞서 했던 것처럼 2+1라고 치고 엔터를 치면 아까와 같은 결과가 나올 것입니다.\n\n\n\nR뿐만 아니라, 많은 다른 언어에서 ’패키지’라고 하는 것은 쉽게 말하자면 유용한 함수들의 묶음을 의미합니다. 기본 R을 설계한 사람들이 R에 내장해두지는 않았지만, 특정 목적을 위해서는 유용함 도구들이 묶여서 ’패키지’로 제공된다고 생각하면 되겠습니다. 비유하자면, 여러분들이 매일 사용하는 ’카카오톡’이 R이라고 해 보죠. 카카오톡 안에는 기본적인 채팅 기능 안에도 수많은 다른 기능들이 있지요? 선물을 주고 받을 수도 있고, 음식을 주문할 수도 있고, 쇼핑을 할 수도 있습니다. 물론 모든 이용자들이 이 기능들을 모두 사용하지는 않지요. 하지만, 어떤 사람들은 자주 사용합니다. 이러한 세부 기능에 해당 하는 일종의 카카오톡 안의 ’미니 프로그램’을 R에서는 패키지라고 부른다고 생각하면 되겠습니다.\n\n\n\n카카오 미니프로그램\n\n\nR에서 패키지를 부르는 방법은 다음과 같습니다.\n\nlibrary(stats)\n\nlibrary()는 괄호가 있으니, 패키지를 부르는 ’함수’일 것이고, 괄호 안에는 부르고 싶은 패키지의 이름을 따옴표 없이 쓰면 됩니다. 여기서는 R을 설치할 때 같이 설치되는 stats라는 패키지를 불렀습니다.\n\n\n\n패키지 종류\n\n\n그런데 R이 설치될 때 모든 패키지가 함께 설치되는 것은 아닙니다. 사실 그렇지 않은 패키지가 훨씬 많지요. 심지어 패키지는 여러분도 만들 수 있습니다. 그렇게 개인이 여러 목적으로 만든 비공식 패키지까지 포함한다면, 세상에는 무한히 많은 R 패키지들이 있습니다. 하지만, 우리가 자주 사용하게될 패키지는 R개발진들의 관리 감독 아래 있는 ‘공식’ 패키지들입니다. 공식 패키지이지만, R과 함께 설치되지 않는 패키지를 설치하기 위해서는 다음과 같은 함수를 실행시키면 됩니다 (여기서는 따옴표가 필요합니다!).\n\ninstall.packages(\"tidyverse\")\n\n물론, 설치만 한다고 해서 바로 이 패키지를 사용할 수 있는 것은 아닙니다. 아까 stats 패키지의 예에서처럼, tidyverse 패키지도 다음과 같이 불러주어야 합니다.\n\n\n\n\n\n\nNote\n\n\n\n패키지 이름을 따옴표로 감싸지 않으면, 패키지가 설치되지 않습니다.\n\n\n\nlibrary(tidyverse)\n\n이 함수를 실행시키면 tidyverse라는 패키지를 사용할 준비가 된 것입니다.\n이 강의에서는 tidyverse 이외에도 다른 여러 패키지들을 사용할 예정입니다. 이 패키지들을 한 번에 설치하기 위해 다음과 같은 명령을 콘솔에서 실행시켜 주세요.\n\ninstall.packages(c(\"tidyverse\", \"purrr\", \"tidytext\", \"tidygraph\", \"igraph\",\n                   \"networkD3\", \"widyr\", \"ggraph\", \"readxl\", \"httr\", \"glue\",\n                   \"jsonlite\", \"shiny\", \"showtext\"))\n\n\n\n방금 tidyverse 패키지를 설치하고 불러왔는데요, 여기서 패키지를 ’설치’한다는 것과 ’불러온다’는 것의 의미에 대해 잠깐 생각해볼 필요가 있습니다.\n여러분이 일상적으로 윈도우 또는 맥OS 상에서 어떤 소프트웨어를 ‘설치’하면 그것은 어디에 저장되었다는 것을 의미하나요? 당연히 HDD, SSD와 같은 ’저장장치’ 입니다. 그래야, 컴퓨터를 껐다 다시 키더라도, 다시 ’설치’할 필요가 없을테니까요. tidyverse 패키지를 설치했다는 것도 비슷한 의미입니다. 설치한 패키지는 저장장치 어디엔가 저장되어 있습니다.\n\n따라서, 설치는 한 번 했다면 다시 할 필요가 없습니다.\n\n그런데 여러분 설치한 소프트웨어가 항상 켜져있나요? 물론 아닙니다. 그 소프트웨어를 실행시켜야지요. 실행시킨다는 것은 뭘까요? 여러 의미가 있지만, 가장 기본적으로는 저장장치에 설치되어 있는 해당 프로그램을 컴퓨터 메모리 상에 ’불러온다’는 것입니다. 가끔 여러분들 너무 많은 소프트웨어를 동시에 열어두면 컴퓨터가 느려져서 몇몇 사용하지 않는 프로그램을 꺼야했던 경험이 있을 것입니다. 프로그램을 껐다는 것은 반대로 메모리에서 지운다는 것을 의미하겠지요. 따라서 메모리에 여유 공간을 조금 확보하려고 프로그램을 끄는 것입니다. 이렇게 프로그램을 켠다는 것은 R 패키지로 치면 패키지를 로드하는 과정과 유사합니다.\n아까의 예에서처럼 library(tidyverse)라는 함수를 실행시키면, 저장장치에 저장되어 있던 tidyverse 패키지가 메모리로 불러와집니다. 그런데 메모리는 어떤 특성을 가지고 있었나요? 컴퓨터를 꺼도, 해당 정보에 할당된 이름이 사라져도, 메모리에서 언제든 사라질 수 있습니다. 이것은 무슨 이야기일까요? 여러분들이 Rstudio를 끄는 순간, 또는 Rstudio 안에서 다른 프로젝트로 이동하는 순간, 불러왔던 패키지는 메모리에 존재하지 않는 것이 됩니다. 그러니,\n\n패키지를 불러오는 것은 Rstudio를 새로 켤 때마다, 또는 새로운 프로젝트로 이동할 때마다, 매번 다시 해야 합니다!\n\n\n\n\n\nKoNLP는 한국어 자연어 처리를 R 패키지 입니다. 사실, KoNLP는 R이 아니라 JAVA라는 다른 언어에서 작동하는 패키지이고, R의 KoNLP 패키지는 JAVA KoNLP를 작동하기 위한 리모컨과 같은 역할을 합니다. 다른 말로는 ’wrapper’라고 하지요. 이 때문에, R에서 KoNLP를 작동시키기 위해서는 JAVA 언어를 함께 설치해야 합니다. 또 하나 복잡한 문제는 KoNLP가 R의 공식 패키지가 아니라는 것입니다. 이러한 이유로 인해서 KoNLP의 설치 방식은 다소 복잡합니다. 그 중 가장 간단하다고 생각하는 설치 과정은 다음과 같습니다.\n\nmultilinguer' 패키지를 이용한JAVA` 설치.\nKoNLP 패키지 수동 설치.\nCli 패키지 수동 설치.\nscala-library-2.11.8.jar 파일 다운로드.\n\n자세한 설치 과정은 다른 분들이 이미 잘 작성해 둔 블로그 포스트들을 참조해주시기 바랍니다.\nJAVA 설치는 다음 블로그를 참조해주세요.\nhttps://e-datanews.tistory.com/155\n나머지 2,3,4 단계 과정은 다음 포스트를 참조해주세요.\nhttps://m.blog.naver.com/meta_com/223021590616\n\n\n\n\n\n\nNote\n\n\n\n윈도우즈 이용자들은 앞서 설치하기로 한 RTools를 설치하지 않았다면, 위의 과정은 잘 진행되지 않습니다.\n많은 분들 컴퓨터에 이미 JAVA가 설치되어 있을 가능성이 높지만, 첫번째 블로그 포스트에서 안내하는대로, multilinguer 패키지의 install_jdk() 함수를 실행시켜주는 편이 오류의 가능성을 줄일 수 있습니다.\n\n\n모든 설치가 끝나면, 다음 명령어를 차례로 콘솔에서 실행 해 보세요.\n\nlibrary(KoNLP)   # 패키지 이름에서 'o'는 소문자 입니다.\n\nChecking user defined dictionary!\n\nSimplePos22(\"KoNLP 설치를 성공적으로 완료하였습니다.\")\n\n$KoNLP\n[1] \"KoNLP/F\"\n\n$설치를\n[1] \"설치/NC+를/JC\"\n\n$성공적으로\n[1] \"성공적/NC+으로/JC\"\n\n$완료하였습니다\n[1] \"완료/NC+하/XS+었/EP+습니다/EF\"\n\n$.\n[1] \"./SF\"\n\n\n이 코드가 에러 없이 실행되면, KoNLP가 잘 설치된 것입니다.\n\n\n\n본 강의에서는 한국전자통신연구원에서 개발한 ‘개체명 인식’ 분류기를 이용할 것입니다. 이는 트레이닝이 완료된 기계학습 모형이지만, 우리는 해당 기계학습 모형을 직접 각자의 컴퓨터에 로드하는 것이 아니라, 인터넷으로 우리가 가진 자연어 데이터를 ETRI로 전송하여 분류한 결과를 전송 받는 방식으로 작업할 예정입니다.\n이를 위해서는 ETRI로부터 AI Open AI Key를 발급받아야 합니다. 이를 위해서는 다음 웹사이트를 방문하세요.\nhttps://aiopen.etri.re.kr/keyMain\n발급 신청이 완료된 후, ‘API Key 확인’ 메뉴에서 발급이 확인되면 API를 사용할 준비가 된 것입니다. API Key는 긴 문자열 형태인데, 이는 강의 전에 미리 복사해 사용할 수 있도록 준비해두기 바랍니다.\n\n\n\n\n\n\nNote\n\n\n\n미리 발급 받는 API 인증키를 워크샵에서 사용할 수 있도록 복사해 두세요.\n\n\n\n\n\n강의 시간에 사용할 코리아 디아스포라 인터뷰 데이터 역시 경북대 사회과학연구원에서 제공하는 API를 통해서 다운 받아 사용할 에정입니다. 현재 API 키 발급 시스템이 개발 중에 있기 때문에, 수업용으로 미리 발급해둔 공동 키를 사용하겠습니다.\n다음 명령어를 R 콘솔에서 차례로 실행시켜보았을 때 에러 없이 아래와 같은 결과가 얻어진다면, 준비가 완료된 것입니다.\n\nlibrary(httr)\nlibrary(jsonlite)\n\nres &lt;- GET(url=\"https://koddas.knu.ac.kr/api/v1/statement\",\n           query=list(key=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImFwaXVzZXIiLCJpYXQiOjE3MzUyOTc0MDIsImV4cCI6MTc2NjgzMzQwMn0.q9upgIiYB6haOzc-aUUlwXk5qKvydFZtmDVzXarI1VI\",\n                      page=1,\n                      limit=\"5\",\n                      bookNumber=\"28\"))\n\ndtString &lt;- content(res, type=\"text\", encoding=\"utf-8\")\n\nfromJSON(dtString)\n\n     id bookId categoryId page type\n1 27743     28         NA    0 TEXT\n2 27744     28         NA    0 TEXT\n3 27745     28         NA    0 TEXT\n4 27746     28         NA    0 TEXT\n5 27747     28         NA    2 TEXT\n                                        content\n1              카타리베 활동가 배동록의 생애사 \n2                            박신규·이토히로코\n3     경북대학교 사회과학연구원 인문사회연구소 \n4 도서출판 책과세계 재외한인 구술생애사 총서 28\n5                                        서 문"
  },
  {
    "objectID": "1_prerequisite.html#r-설치",
    "href": "1_prerequisite.html#r-설치",
    "title": "강의 사전 준비",
    "section": "",
    "text": "R을 설치하기 위해서는 R다운로드 페이지로 이동해야 합니다.\n\n\n\nR 다운로드 페이지\n\n\n여기에서 사용하는 운영체제에 맞추어 링크를 선택합니다. 여기서는 윈도우즈 사용환경을 가정하고 ’Download R for Windows’를 클릭합니다 (물론 맥 이용자나 리눅스 이용자라면 다른 옵션을 선택하시면 됩니다). 그러면 다음과 같은 화면이 나타날 것입니다.\n 윈도우즈 이용자들은 두 가지를 설치해야 합니다. 하나는 ’base’라고 표시되어 있는 R프로그램 그 자체입니다. 해당 하이퍼링크를 클릭하면 이동하는 페이지에 ’Download R-4.4.2 for Windows’라고 표시된 하이퍼링크가 있을 것입니다 (4.4.2이라는 버전을 나타내는 숫자는 최신 업데이트에 따라 달라질 수 있습니다). 이를 클릭하면 다음 설치 파일이 다운로드 됩니다.\n두번째로 다운로드 받을 파일은 위의 화면 캡춰에서 Rtools라고 표시되어 있는 R의 확장 프로그램 입니다. 이 역시 R의 다양한 기능을 활용하기 위해서 반드시 필요합니다. 해당 링크를 클릭하여 앞서 다운 받은 R 버전에 맞는 RTools를 다운받습니다. 예컨대 앞서 R 4.4.0버전을 다운 받았으니, ’RTools 4.4’을 다운받는 것이지요.\n\n\n\n\n\n\nNote\n\n\n\n윈도우즈 사용자는 반드시 R과 RTools 모두를 설치해야 합니다. RTools를 설치하지 않은 경우, 뒤에서 설명할 여러 패키지 설치 과정이 작동하지 않을 수 있습니다.\n단, 맥 사용자는 R만 설치하면 됩니다.\n\n\n이제 두 설치파일을 다운로드 받은 순서대로 더블클릭하여 설치를 완료하면 됩니다. 여기서도, 한 가지 주의사항이 있습니다. R은 오픈소스 언어이기 때문에, 상업 프로그램처럼 다양한 언어를 부드럽게 처리하지못하는 경우가 있습니다. 관련해서 가장 많은 에러를 양산하는 문제 중 하나가 R이 설치된 경로상에 한글이 섞여 있는 경우 입니다. 예컨대, 윈도우즈의 이용자 이름이 자신의 이름으로 되어 있다면, 설치경로가 에러를 만들어 내는 경우가 많습니다. 예컨대, “C:.2”과 같은 주소는 한글이 포함되어 좋지 않다는 이야기 입니다. “C:Files.2”과 같은 설치 경로는 한글이 포함되어 있지 않으므로, 문제가 없습니다. 따라서, 윈도우즈 이용자 이름에 알파벳이 아닌 다른 문자가 섞여 있다면, R 설치시 설정하는 모든 경로를 이용자 이름이 섞이지 않도록 적절하게 수정해 주는 것이 좋습니다.\n\n\n\n\n\n\nNote\n\n\n\nR 설치 경로는 알파벳만으로 이루어지도록 주의하세요."
  },
  {
    "objectID": "1_prerequisite.html#rstudio-설치",
    "href": "1_prerequisite.html#rstudio-설치",
    "title": "강의 사전 준비",
    "section": "",
    "text": "Rstudio는 오픈소스 프로젝트가 아니라 사기업인 Posit에 의해 관리되기 때문에 다운로드 및 설치가 더욱 쉽습니다. 다음 링크를 따라가서, 각자의 운영체제에 맞는 설치파일을 다운 받은 후 실행해 주면 됩니다. 다만, Rstuio의 설치는 R 설치가 모두 완료된 다음 해 주는 것이 불필요한 에러를 방지할 수 있습니다.\n\n\n\nRstudio 다운로드 페이지"
  },
  {
    "objectID": "1_prerequisite.html#r과-rstudio-처음-이용하기",
    "href": "1_prerequisite.html#r과-rstudio-처음-이용하기",
    "title": "강의 사전 준비",
    "section": "",
    "text": "먼저, R은 윈도우 시작 버튼을 눌러 실행할 수 있습니다. 시작 화면에서 전체 애플리케이션을 열면, 여러분의 컴퓨터에 설치된R은 보통 다음과 같이 나타납니다.\n\n\n\n윈도우즈에서 R 실행하기\n\n\n제 경우에는 여러 버전의 R을 설치하다보니 여러 가지의 R이 보이는데요, 그 중에서 버전이 가장 높은 것을 선택하시면 됩니다. i386과 x64는 여러분이 사용하는 컴퓨터의 환경과 관련이 있는데, 대부분의 요즘 컴퓨터는 x64라고 생각하시면 됩니다. 따라서 위의 경우에는 R x64 4.1.3을 선택하면 되겠네요. 이를 실행하면 다음과 같은 화면이 나타나게 됩니다.\n\n\n\nR 화면\n\n\n화면에 가장 크게 보이는 하얀 창이 바로 R의 핵심인 콘솔(Console) 입니다. 여기에 이러저러한 명령을 하고 엔터를 치면 R은 해당 명령을 수행한 결과를 표시해 줍니다. R을 사용하는 가장 단순한 방법은 계산기 처럼 활용하는 것입니다. 예컨대 2+1이라는 연산을 한다고 해 볼까요? 그 때는 가장 단순하게 다음과 2+1이라고 콘솔에 쓰시고 엔터키를 치면 됩니다. 그러면 다음과 같은 결과를 볼 것입니다.\n\n2+1\n\n[1] 3\n\n\n물론, 여러분이 나중에 작성하게될 코드는 이보다 복잡할 것입니다. 그렇다면 코드를 한줄 쓰고 실행하는 이런 단순한 방식은 아무래도 불편할 것입니다. 따라서, 대부분의 이용자들은 위와 같은 화면에서 R을 사용하지 않습니다. 대신 Rstudio라는 환경을 사용하지요.\n여러분 컴퓨터에 설치된 Rstudio를 사용하는 가장 간단한 방법은 윈도우즈 화면 하단 시작 버튼 옆의 검색창에 ’Rstudio’라고 검색해 보는 것입니다. Rstudio가 올바르게 설치되어 있다면, 다음과 유사한 화면을 보게 될 것입니다.\n\n\n\nRstudio 시작\n\n\n이제 Rstudio를 선택해서 프로그램을 실행시키면 다음과 같은 화면이 나타납니다.\n\n\n\nRstudio 첫 화면\n\n\n바탕화면은 초기설정에 따라 위와 같이 어두운 색이기도, 밝은 색이기도 합니다. Rstudio는 R을 편리하게 사용할 수 있도록 도와줄 뿐만 아니라, R의 더 많은 기능을 이끌어내기 위해 만들어낸 인터페이스라고 생각하시면 됩니다. 전문적인 용어로는 통합개발환경(IDE)라고 하지요. 비유하자면, R가 엔진이라면, Rstudio는 여러분이 직접 운전하는 자동차와 같은 관계라고 생각하시면 되겠습니다. 엔진을 이용해 직접 가능한 탈것을 만드는 사람은 극히 제한적이듯, 대부분의 사람들은 Rstudio를 사용하지, R을 직접 사용하지 않습니다. 따라서, 여러분들 역시 앞으로 Rstudio만을 사용하게 될 것입니다.\n\n\n\nR과 Rstudio 간의 관계\n\n\nRstudio의 초기 화면에 보이는 가장 큰 공간은 R의 콘솔 입니다. 앞서 R의 기본 인터페이스에서 본 콘솔과 같은 콘솔이지요. 따라서 앞서 했던 것처럼 2+1라고 치고 엔터를 치면 아까와 같은 결과가 나올 것입니다."
  },
  {
    "objectID": "1_prerequisite.html#패키지-설치",
    "href": "1_prerequisite.html#패키지-설치",
    "title": "강의 사전 준비",
    "section": "",
    "text": "R뿐만 아니라, 많은 다른 언어에서 ’패키지’라고 하는 것은 쉽게 말하자면 유용한 함수들의 묶음을 의미합니다. 기본 R을 설계한 사람들이 R에 내장해두지는 않았지만, 특정 목적을 위해서는 유용함 도구들이 묶여서 ’패키지’로 제공된다고 생각하면 되겠습니다. 비유하자면, 여러분들이 매일 사용하는 ’카카오톡’이 R이라고 해 보죠. 카카오톡 안에는 기본적인 채팅 기능 안에도 수많은 다른 기능들이 있지요? 선물을 주고 받을 수도 있고, 음식을 주문할 수도 있고, 쇼핑을 할 수도 있습니다. 물론 모든 이용자들이 이 기능들을 모두 사용하지는 않지요. 하지만, 어떤 사람들은 자주 사용합니다. 이러한 세부 기능에 해당 하는 일종의 카카오톡 안의 ’미니 프로그램’을 R에서는 패키지라고 부른다고 생각하면 되겠습니다.\n\n\n\n카카오 미니프로그램\n\n\nR에서 패키지를 부르는 방법은 다음과 같습니다.\n\nlibrary(stats)\n\nlibrary()는 괄호가 있으니, 패키지를 부르는 ’함수’일 것이고, 괄호 안에는 부르고 싶은 패키지의 이름을 따옴표 없이 쓰면 됩니다. 여기서는 R을 설치할 때 같이 설치되는 stats라는 패키지를 불렀습니다.\n\n\n\n패키지 종류\n\n\n그런데 R이 설치될 때 모든 패키지가 함께 설치되는 것은 아닙니다. 사실 그렇지 않은 패키지가 훨씬 많지요. 심지어 패키지는 여러분도 만들 수 있습니다. 그렇게 개인이 여러 목적으로 만든 비공식 패키지까지 포함한다면, 세상에는 무한히 많은 R 패키지들이 있습니다. 하지만, 우리가 자주 사용하게될 패키지는 R개발진들의 관리 감독 아래 있는 ‘공식’ 패키지들입니다. 공식 패키지이지만, R과 함께 설치되지 않는 패키지를 설치하기 위해서는 다음과 같은 함수를 실행시키면 됩니다 (여기서는 따옴표가 필요합니다!).\n\ninstall.packages(\"tidyverse\")\n\n물론, 설치만 한다고 해서 바로 이 패키지를 사용할 수 있는 것은 아닙니다. 아까 stats 패키지의 예에서처럼, tidyverse 패키지도 다음과 같이 불러주어야 합니다.\n\n\n\n\n\n\nNote\n\n\n\n패키지 이름을 따옴표로 감싸지 않으면, 패키지가 설치되지 않습니다.\n\n\n\nlibrary(tidyverse)\n\n이 함수를 실행시키면 tidyverse라는 패키지를 사용할 준비가 된 것입니다.\n이 강의에서는 tidyverse 이외에도 다른 여러 패키지들을 사용할 예정입니다. 이 패키지들을 한 번에 설치하기 위해 다음과 같은 명령을 콘솔에서 실행시켜 주세요.\n\ninstall.packages(c(\"tidyverse\", \"purrr\", \"tidytext\", \"tidygraph\", \"igraph\",\n                   \"networkD3\", \"widyr\", \"ggraph\", \"readxl\", \"httr\", \"glue\",\n                   \"jsonlite\", \"shiny\", \"showtext\"))\n\n\n\n방금 tidyverse 패키지를 설치하고 불러왔는데요, 여기서 패키지를 ’설치’한다는 것과 ’불러온다’는 것의 의미에 대해 잠깐 생각해볼 필요가 있습니다.\n여러분이 일상적으로 윈도우 또는 맥OS 상에서 어떤 소프트웨어를 ‘설치’하면 그것은 어디에 저장되었다는 것을 의미하나요? 당연히 HDD, SSD와 같은 ’저장장치’ 입니다. 그래야, 컴퓨터를 껐다 다시 키더라도, 다시 ’설치’할 필요가 없을테니까요. tidyverse 패키지를 설치했다는 것도 비슷한 의미입니다. 설치한 패키지는 저장장치 어디엔가 저장되어 있습니다.\n\n따라서, 설치는 한 번 했다면 다시 할 필요가 없습니다.\n\n그런데 여러분 설치한 소프트웨어가 항상 켜져있나요? 물론 아닙니다. 그 소프트웨어를 실행시켜야지요. 실행시킨다는 것은 뭘까요? 여러 의미가 있지만, 가장 기본적으로는 저장장치에 설치되어 있는 해당 프로그램을 컴퓨터 메모리 상에 ’불러온다’는 것입니다. 가끔 여러분들 너무 많은 소프트웨어를 동시에 열어두면 컴퓨터가 느려져서 몇몇 사용하지 않는 프로그램을 꺼야했던 경험이 있을 것입니다. 프로그램을 껐다는 것은 반대로 메모리에서 지운다는 것을 의미하겠지요. 따라서 메모리에 여유 공간을 조금 확보하려고 프로그램을 끄는 것입니다. 이렇게 프로그램을 켠다는 것은 R 패키지로 치면 패키지를 로드하는 과정과 유사합니다.\n아까의 예에서처럼 library(tidyverse)라는 함수를 실행시키면, 저장장치에 저장되어 있던 tidyverse 패키지가 메모리로 불러와집니다. 그런데 메모리는 어떤 특성을 가지고 있었나요? 컴퓨터를 꺼도, 해당 정보에 할당된 이름이 사라져도, 메모리에서 언제든 사라질 수 있습니다. 이것은 무슨 이야기일까요? 여러분들이 Rstudio를 끄는 순간, 또는 Rstudio 안에서 다른 프로젝트로 이동하는 순간, 불러왔던 패키지는 메모리에 존재하지 않는 것이 됩니다. 그러니,\n\n패키지를 불러오는 것은 Rstudio를 새로 켤 때마다, 또는 새로운 프로젝트로 이동할 때마다, 매번 다시 해야 합니다!"
  },
  {
    "objectID": "1_prerequisite.html#konlp-설치",
    "href": "1_prerequisite.html#konlp-설치",
    "title": "강의 사전 준비",
    "section": "",
    "text": "KoNLP는 한국어 자연어 처리를 R 패키지 입니다. 사실, KoNLP는 R이 아니라 JAVA라는 다른 언어에서 작동하는 패키지이고, R의 KoNLP 패키지는 JAVA KoNLP를 작동하기 위한 리모컨과 같은 역할을 합니다. 다른 말로는 ’wrapper’라고 하지요. 이 때문에, R에서 KoNLP를 작동시키기 위해서는 JAVA 언어를 함께 설치해야 합니다. 또 하나 복잡한 문제는 KoNLP가 R의 공식 패키지가 아니라는 것입니다. 이러한 이유로 인해서 KoNLP의 설치 방식은 다소 복잡합니다. 그 중 가장 간단하다고 생각하는 설치 과정은 다음과 같습니다.\n\nmultilinguer' 패키지를 이용한JAVA` 설치.\nKoNLP 패키지 수동 설치.\nCli 패키지 수동 설치.\nscala-library-2.11.8.jar 파일 다운로드.\n\n자세한 설치 과정은 다른 분들이 이미 잘 작성해 둔 블로그 포스트들을 참조해주시기 바랍니다.\nJAVA 설치는 다음 블로그를 참조해주세요.\nhttps://e-datanews.tistory.com/155\n나머지 2,3,4 단계 과정은 다음 포스트를 참조해주세요.\nhttps://m.blog.naver.com/meta_com/223021590616\n\n\n\n\n\n\nNote\n\n\n\n윈도우즈 이용자들은 앞서 설치하기로 한 RTools를 설치하지 않았다면, 위의 과정은 잘 진행되지 않습니다.\n많은 분들 컴퓨터에 이미 JAVA가 설치되어 있을 가능성이 높지만, 첫번째 블로그 포스트에서 안내하는대로, multilinguer 패키지의 install_jdk() 함수를 실행시켜주는 편이 오류의 가능성을 줄일 수 있습니다.\n\n\n모든 설치가 끝나면, 다음 명령어를 차례로 콘솔에서 실행 해 보세요.\n\nlibrary(KoNLP)   # 패키지 이름에서 'o'는 소문자 입니다.\n\nChecking user defined dictionary!\n\nSimplePos22(\"KoNLP 설치를 성공적으로 완료하였습니다.\")\n\n$KoNLP\n[1] \"KoNLP/F\"\n\n$설치를\n[1] \"설치/NC+를/JC\"\n\n$성공적으로\n[1] \"성공적/NC+으로/JC\"\n\n$완료하였습니다\n[1] \"완료/NC+하/XS+었/EP+습니다/EF\"\n\n$.\n[1] \"./SF\"\n\n\n이 코드가 에러 없이 실행되면, KoNLP가 잘 설치된 것입니다."
  },
  {
    "objectID": "1_prerequisite.html#ner-nlp-받기",
    "href": "1_prerequisite.html#ner-nlp-받기",
    "title": "강의 사전 준비",
    "section": "",
    "text": "본 강의에서는 한국전자통신연구원에서 개발한 ‘개체명 인식’ 분류기를 이용할 것입니다. 이는 트레이닝이 완료된 기계학습 모형이지만, 우리는 해당 기계학습 모형을 직접 각자의 컴퓨터에 로드하는 것이 아니라, 인터넷으로 우리가 가진 자연어 데이터를 ETRI로 전송하여 분류한 결과를 전송 받는 방식으로 작업할 예정입니다.\n이를 위해서는 ETRI로부터 AI Open AI Key를 발급받아야 합니다. 이를 위해서는 다음 웹사이트를 방문하세요.\nhttps://aiopen.etri.re.kr/keyMain\n발급 신청이 완료된 후, ‘API Key 확인’ 메뉴에서 발급이 확인되면 API를 사용할 준비가 된 것입니다. API Key는 긴 문자열 형태인데, 이는 강의 전에 미리 복사해 사용할 수 있도록 준비해두기 바랍니다.\n\n\n\n\n\n\nNote\n\n\n\n미리 발급 받는 API 인증키를 워크샵에서 사용할 수 있도록 복사해 두세요."
  },
  {
    "objectID": "1_prerequisite.html#koddas-db-api-받기",
    "href": "1_prerequisite.html#koddas-db-api-받기",
    "title": "강의 사전 준비",
    "section": "",
    "text": "강의 시간에 사용할 코리아 디아스포라 인터뷰 데이터 역시 경북대 사회과학연구원에서 제공하는 API를 통해서 다운 받아 사용할 에정입니다. 현재 API 키 발급 시스템이 개발 중에 있기 때문에, 수업용으로 미리 발급해둔 공동 키를 사용하겠습니다.\n다음 명령어를 R 콘솔에서 차례로 실행시켜보았을 때 에러 없이 아래와 같은 결과가 얻어진다면, 준비가 완료된 것입니다.\n\nlibrary(httr)\nlibrary(jsonlite)\n\nres &lt;- GET(url=\"https://koddas.knu.ac.kr/api/v1/statement\",\n           query=list(key=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImFwaXVzZXIiLCJpYXQiOjE3MzUyOTc0MDIsImV4cCI6MTc2NjgzMzQwMn0.q9upgIiYB6haOzc-aUUlwXk5qKvydFZtmDVzXarI1VI\",\n                      page=1,\n                      limit=\"5\",\n                      bookNumber=\"28\"))\n\ndtString &lt;- content(res, type=\"text\", encoding=\"utf-8\")\n\nfromJSON(dtString)\n\n     id bookId categoryId page type\n1 27743     28         NA    0 TEXT\n2 27744     28         NA    0 TEXT\n3 27745     28         NA    0 TEXT\n4 27746     28         NA    0 TEXT\n5 27747     28         NA    2 TEXT\n                                        content\n1              카타리베 활동가 배동록의 생애사 \n2                            박신규·이토히로코\n3     경북대학교 사회과학연구원 인문사회연구소 \n4 도서출판 책과세계 재외한인 구술생애사 총서 28\n5                                        서 문"
  },
  {
    "objectID": "2_tidytext.html",
    "href": "2_tidytext.html",
    "title": "Tidy한 텍스트 분석",
    "section": "",
    "text": "library(tidyverse)\nlibrary(purrr)\nlibrary(tidytext)\nlibrary(KoNLP)\nlibrary(readxl)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(shiny)\n\n\n\n\n\n\nres &lt;- GET(url=\"https://koddas.knu.ac.kr/api/v1/statement\",\n           query=list(key=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImFwaXVzZXIiLCJpYXQiOjE3MzUyOTc0MDIsImV4cCI6MTc2NjgzMzQwMn0.q9upgIiYB6haOzc-aUUlwXk5qKvydFZtmDVzXarI1VI\",\n                      page=7,\n                      limit=\"2\",\n                      bookNumber=\"28\"))\n\ndtString &lt;- content(res, type=\"text\", encoding=\"utf-8\")\n\ndt &lt;- fromJSON(dtString)\n\n\n\n\nK-디아스포라 API로부터 반복적으로 데이터를 불러오기 위한 함수입니다.\n\nurl &lt;- \"https://koddas.knu.ac.kr/api/v1/statement\"\nkey &lt;- \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImFwaXVzZXIiLCJpYXQiOjE3MzUyOTc0MDIsImV4cCI6MTc2NjgzMzQwMn0.q9upgIiYB6haOzc-aUUlwXk5qKvydFZtmDVzXarI1VI\"\n\ngetPara &lt;- function(page, book){\n    res &lt;- GET(url=url,\n               query=list(key=key,\n                          page=page,\n                          limit=100,\n                          bookNumber=book))\n    dtString &lt;- content(res, type=\"text\", encoding=\"utf-8\")\n\n    dt &lt;- fromJSON(dtString)    \n\n    return(dt)\n    }\n\n28권부터 31권까지 불러와서 list로 저장.\n\nlist_big &lt;- list()\npage &lt;- 1\ni &lt;- 1\n    \nfor (book in 28:31) {     \n    while (TRUE) {\n        dt &lt;- getPara(page=page, book=book)\n        \n        if (length(dt) == 0) {\n            break\n        }\n        list_big[[i]] &lt;- dt\n        page &lt;- page + 1\n        i &lt;- i + 1\n    }\n    page &lt;- 1\n}\n\nlist_big 안에 저장된 여러 테이블을 결합.\n\ndf &lt;- bind_rows(list_big)\n\n\ndf |&gt;\n    filter(nchar(content) &gt; 100)\n\n\n#dt &lt;- getPara(1,31)\n\n\n\n\n\n\nfilepath &lt;- \"5. 총서 텍스트DB 최종/\"\ndt &lt;- paste0(filepath, list.files(filepath)) |&gt;\n    set_names() |&gt;\n    map(~read_excel(.)) |&gt;\n    map(~rename(., \"para\" = 1)) |&gt;\n    map(~mutate(., para=as.character(para))) |&gt;\n    bind_rows(.id=\"book\") |&gt;\n    mutate(book = str_replace(book, \".*/book\", \"\"),\n           book = str_replace(book, \"( 최종.xlsm)|( 최종.xlsx)|( 최종\\\\(일부 수정\\\\).xlsm)\", \"\"),\n           book = as.numeric(book)) |&gt; \n    filter(book &gt;= 28)                               # 28권 이후 공개\n\n\n\n\n\ntidydt &lt;- dt |&gt;\n    select(book, para, TEXT) |&gt;\n    unnest_tokens(word, TEXT, token=SimplePos22)\nbeep()\n\n\ntidydt |&gt;\n    mutate(word = str_replace(word, \"\\\\+(.*)\", \"\")) |&gt;\n    filter(str_detect(word, \"/nc|/nq\")) |&gt;\n    separate_wider_delim(word, delim=\"/\", names=c(\"word\", \"morph\"), too_many=\"drop\") |&gt;\n    filter(morph!=\"nc\")\n\n\n\n\n\nner &lt;- function(text) {\n    body = paste0('{\"argument\": {\"text\": \"', text, '\", \"analysis_code\": \"ner\"}}')\n    res &lt;- POST(url=\"http://aiopen.etri.re.kr:8000/WiseNLU_spoken\",\n            body= body,\n            encode=\"raw\",\n            add_headers(.headers=c(\"Content-Type\" = \"application/json; charset=UTF-8\",\n                                   \"Authorization\"=\"45a48207-93d4-4d40-9b10-1db71ea2b3ce\"))) \n    \n    sentences &lt;- fromJSON(content(res, as=\"text\", encoding='UTF-8'), simplifyVector=FALSE)$return_object$sentence\n    \n    out &lt;- 1:length(sentences) |&gt;\n        map(~sentences[[.x]]$NE) |&gt;\n        map(~bind_rows(.x)) |&gt;\n        bind_rows(.id=\"sentence\")\n    \n    return(out)\n}\n\nner_para &lt;- function(row){\n    #print(row$TEXT)\n    nered &lt;- ner(row$TEXT)\n    nered$para &lt;- row$para\n    nered$book &lt;- row$book\n    \n    return(nered)\n}\n\n\nlist_large &lt;- list()\n\nfor (i in 1:1000){\n    list_large[[i]] &lt;- ner_para(dt[i, ])\n}\n\n\ndt_ner &lt;- bind_rows(list_large)\n\nNER 분석 결과물을 로컬 파일로 저장.\n\n#saveRDS(dt_ner, \"dt_ner.rds\")\n#dt_ner &lt;- readRDS(\"dt_ner.rds\")"
  },
  {
    "objectID": "2_tidytext.html#api를-이용한-k-디아스포라-db-이용",
    "href": "2_tidytext.html#api를-이용한-k-디아스포라-db-이용",
    "title": "Tidy한 텍스트 분석",
    "section": "",
    "text": "res &lt;- GET(url=\"https://koddas.knu.ac.kr/api/v1/statement\",\n           query=list(key=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImFwaXVzZXIiLCJpYXQiOjE3MzUyOTc0MDIsImV4cCI6MTc2NjgzMzQwMn0.q9upgIiYB6haOzc-aUUlwXk5qKvydFZtmDVzXarI1VI\",\n                      page=7,\n                      limit=\"2\",\n                      bookNumber=\"28\"))\n\ndtString &lt;- content(res, type=\"text\", encoding=\"utf-8\")\n\ndt &lt;- fromJSON(dtString)\n\n\n\n\nK-디아스포라 API로부터 반복적으로 데이터를 불러오기 위한 함수입니다.\n\nurl &lt;- \"https://koddas.knu.ac.kr/api/v1/statement\"\nkey &lt;- \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImFwaXVzZXIiLCJpYXQiOjE3MzUyOTc0MDIsImV4cCI6MTc2NjgzMzQwMn0.q9upgIiYB6haOzc-aUUlwXk5qKvydFZtmDVzXarI1VI\"\n\ngetPara &lt;- function(page, book){\n    res &lt;- GET(url=url,\n               query=list(key=key,\n                          page=page,\n                          limit=100,\n                          bookNumber=book))\n    dtString &lt;- content(res, type=\"text\", encoding=\"utf-8\")\n\n    dt &lt;- fromJSON(dtString)    \n\n    return(dt)\n    }\n\n28권부터 31권까지 불러와서 list로 저장.\n\nlist_big &lt;- list()\npage &lt;- 1\ni &lt;- 1\n    \nfor (book in 28:31) {     \n    while (TRUE) {\n        dt &lt;- getPara(page=page, book=book)\n        \n        if (length(dt) == 0) {\n            break\n        }\n        list_big[[i]] &lt;- dt\n        page &lt;- page + 1\n        i &lt;- i + 1\n    }\n    page &lt;- 1\n}\n\nlist_big 안에 저장된 여러 테이블을 결합.\n\ndf &lt;- bind_rows(list_big)\n\n\ndf |&gt;\n    filter(nchar(content) &gt; 100)\n\n\n#dt &lt;- getPara(1,31)"
  },
  {
    "objectID": "2_tidytext.html#로컬-텍스트-파일-부르기-api가-작동하지-않는-경우에만-이용",
    "href": "2_tidytext.html#로컬-텍스트-파일-부르기-api가-작동하지-않는-경우에만-이용",
    "title": "Tidy한 텍스트 분석",
    "section": "",
    "text": "filepath &lt;- \"5. 총서 텍스트DB 최종/\"\ndt &lt;- paste0(filepath, list.files(filepath)) |&gt;\n    set_names() |&gt;\n    map(~read_excel(.)) |&gt;\n    map(~rename(., \"para\" = 1)) |&gt;\n    map(~mutate(., para=as.character(para))) |&gt;\n    bind_rows(.id=\"book\") |&gt;\n    mutate(book = str_replace(book, \".*/book\", \"\"),\n           book = str_replace(book, \"( 최종.xlsm)|( 최종.xlsx)|( 최종\\\\(일부 수정\\\\).xlsm)\", \"\"),\n           book = as.numeric(book)) |&gt; \n    filter(book &gt;= 28)                               # 28권 이후 공개"
  },
  {
    "objectID": "2_tidytext.html#tidytext와-konlp를-이용한-형태소-분석-방법.",
    "href": "2_tidytext.html#tidytext와-konlp를-이용한-형태소-분석-방법.",
    "title": "Tidy한 텍스트 분석",
    "section": "",
    "text": "tidydt &lt;- dt |&gt;\n    select(book, para, TEXT) |&gt;\n    unnest_tokens(word, TEXT, token=SimplePos22)\nbeep()\n\n\ntidydt |&gt;\n    mutate(word = str_replace(word, \"\\\\+(.*)\", \"\")) |&gt;\n    filter(str_detect(word, \"/nc|/nq\")) |&gt;\n    separate_wider_delim(word, delim=\"/\", names=c(\"word\", \"morph\"), too_many=\"drop\") |&gt;\n    filter(morph!=\"nc\")"
  },
  {
    "objectID": "2_tidytext.html#etri-ner을-이용한-방법.",
    "href": "2_tidytext.html#etri-ner을-이용한-방법.",
    "title": "Tidy한 텍스트 분석",
    "section": "",
    "text": "ner &lt;- function(text) {\n    body = paste0('{\"argument\": {\"text\": \"', text, '\", \"analysis_code\": \"ner\"}}')\n    res &lt;- POST(url=\"http://aiopen.etri.re.kr:8000/WiseNLU_spoken\",\n            body= body,\n            encode=\"raw\",\n            add_headers(.headers=c(\"Content-Type\" = \"application/json; charset=UTF-8\",\n                                   \"Authorization\"=\"45a48207-93d4-4d40-9b10-1db71ea2b3ce\"))) \n    \n    sentences &lt;- fromJSON(content(res, as=\"text\", encoding='UTF-8'), simplifyVector=FALSE)$return_object$sentence\n    \n    out &lt;- 1:length(sentences) |&gt;\n        map(~sentences[[.x]]$NE) |&gt;\n        map(~bind_rows(.x)) |&gt;\n        bind_rows(.id=\"sentence\")\n    \n    return(out)\n}\n\nner_para &lt;- function(row){\n    #print(row$TEXT)\n    nered &lt;- ner(row$TEXT)\n    nered$para &lt;- row$para\n    nered$book &lt;- row$book\n    \n    return(nered)\n}\n\n\nlist_large &lt;- list()\n\nfor (i in 1:1000){\n    list_large[[i]] &lt;- ner_para(dt[i, ])\n}\n\n\ndt_ner &lt;- bind_rows(list_large)\n\nNER 분석 결과물을 로컬 파일로 저장.\n\n#saveRDS(dt_ner, \"dt_ner.rds\")\n#dt_ner &lt;- readRDS(\"dt_ner.rds\")"
  },
  {
    "objectID": "4_shiny.html",
    "href": "4_shiny.html",
    "title": "웹앱을 이용한 시각화 공유",
    "section": "",
    "text": "웹앱을 이용한 시각화 공유\n\nlibrary(tidyverse)\nlibrary(purrr)\nlibrary(tidytext)\nlibrary(tidygraph)\nlibrary(igraph)\nlibrary(networkD3)\nlibrary(widyr)\nlibrary(KoNLP)\nlibrary(ggraph)\nlibrary(readxl)\nlibrary(beepr)\nlibrary(httr)\nlibrary(glue)\nlibrary(jsonlite)\nlibrary(shiny)\nlibrary(showtext)\nfont_add_google(name = \"Nanum Gothic\", family = \"nanumgothic\")\nshowtext_auto()\n\nshiny 프로젝트 만들기.\n다음과 같은 app.R 프로그램 만들기\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(tidygraph)\nlibrary(igraph)\nlibrary(networkD3)\n\n\n\n#dt_ner &lt;- readRDS(\"dt_ner.rds\")\ngTidy &lt;- readRDS(\"../gTidy.rds\")\nnodeAttr &lt;- readRDS(\"../nodeAttr.rds\")\ndupList &lt;- readRDS(\"../dupList.rds\")\n\nforceN &lt;- function(thres) {\n    gig &lt;- gTidy |&gt; \n        activate(edges) |&gt;\n        filter(weight &gt; thres) |&gt;\n        activate(nodes) |&gt; \n        left_join(nodeAttr |&gt;\n                      filter(!(text %in% dupList)), by=c(\"name\"=\"text\")) |&gt;\n        mutate(degree = centrality_degree()) |&gt;\n        filter(degree != 0) |&gt;\n        as.igraph() \n    gD3 &lt;- gig |&gt;\n        igraph_to_networkD3(group=vertex_attr(gig)$cat)\n    \n    out &lt;- forceNetwork(Links=gD3$links, Nodes=gD3$nodes,\n                        Source = 'source', Target = 'target', NodeID = 'name', Group = 'group',\n                        zoom=TRUE,\n                        # layout\n                        linkDistance = 250,                                                 # link size, if higher, more space between nodes\n                        charge = -50,                                                       # if highly negative, more space betqeen nodes\n                        \n    )\n    \n    return(out)\n}\n\n\n# location algorithm은 바꿀 수 있을지...\n# zoom도 필요.\n# hosting한 후, iframe으로 넣기...\n# 참고자료 알려주기.\n\n# Define UI for application that draws a histogram\nui &lt;- fillPage(\n    page_sidebar(\n        title = \"KODDAS DB 네트워크 시각화\",\n        sidebar = sidebar( sliderInput(\"thres\",\n                                       \"Number of bins:\",\n                                       min = 3,\n                                       max = 10,\n                                       value = 5)),\n        forceNetworkOutput(\"distPlot\")\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderForceNetwork({\n        # forceNetwork(Links=gD3$links, Nodes=gD3$nodes,\n        #              Source = 'source', Target = 'target', NodeID = 'name', Group = 'group',\n        #              zoom=TRUE,\n        #              # layout\n        #              linkDistance = 250,                                                 # link size, if higher, more space between nodes\n        #              charge = -50,                                                       # if highly negative, more space betqeen nodes\n        #              \n        # )\n        forceN(input$thres)\n            })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n웹에 올리기.\n\n&lt;p&gt;이용해서 홈페이지에 embed하기.&lt;/p&gt;\n&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-sidebar-title\"&gt;2025 디지털인문학 R &amp; K-디아스포라 워크샵&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar-title\"&gt;2025 디지털인문학 R &amp; K-디아스포라 워크샵&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:홈\"&gt;홈&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:/index.html\"&gt;/index.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:강의 사전 준비\"&gt;강의 사전 준비&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:/1_prerequisite.html\"&gt;/1_prerequisite.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:R의 기초\"&gt;R의 기초&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:/5_basic.html\"&gt;/5_basic.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:Tidy한 텍스트 분석\"&gt;Tidy한 텍스트 분석&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:/2_tidytext.html\"&gt;/2_tidytext.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:Tidy한 네트워크 분석\"&gt;Tidy한 네트워크 분석&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:/3_tidygraph.html\"&gt;/3_tidygraph.html&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:웹앱을 이용한 시각화 공유\"&gt;웹앱을 이용한 시각화 공유&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-int-navbar:/4_shiny.html\"&gt;/4_shiny.html&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-metatitle\"&gt;2025 디지털인문학 R &amp; K-디아스포라 워크샵&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-twittercardtitle\"&gt;2025 디지털인문학 R &amp; K-디아스포라 워크샵&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-ogcardtitle\"&gt;2025 디지털인문학 R &amp; K-디아스포라 워크샵&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-metasitename\"&gt;2025 디지털인문학 R &amp; K-디아스포라 워크샵&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-twittercarddesc\"&gt;&lt;/span&gt; &lt;span class=\"hidden quarto-markdown-envelope-contents\" data-render-id=\"quarto-ogcardddesc\"&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;/section&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const toggleBodyColorMode = (bsSheetEl) =&gt; {\n    const mode = bsSheetEl.getAttribute(\"data-mode\");\n    const bodyEl = window.document.querySelector(\"body\");\n    if (mode === \"dark\") {\n      bodyEl.classList.add(\"quarto-dark\");\n      bodyEl.classList.remove(\"quarto-light\");\n    } else {\n      bodyEl.classList.add(\"quarto-light\");\n      bodyEl.classList.remove(\"quarto-dark\");\n    }\n  }\n  const toggleBodyColorPrimary = () =&gt; {\n    const bsSheetEl = window.document.querySelector(\"link#quarto-bootstrap\");\n    if (bsSheetEl) {\n      toggleBodyColorMode(bsSheetEl);\n    }\n  }\n  toggleBodyColorPrimary();  \n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const isCodeAnnotation = (el) =&gt; {\n    for (const clz of el.classList) {\n      if (clz.startsWith('code-annotation-')) {                     \n        return true;\n      }\n    }\n    return false;\n  }\n  const onCopySuccess = function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    var currentTitle = button.getAttribute(\"title\");\n    button.setAttribute(\"title\", \"Copied!\");\n    let tooltip;\n    if (window.bootstrap) {\n      button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n      button.setAttribute(\"data-bs-placement\", \"left\");\n      button.setAttribute(\"data-bs-title\", \"Copied!\");\n      tooltip = new bootstrap.Tooltip(button, \n        { trigger: \"manual\", \n          customClass: \"code-copy-button-tooltip\",\n          offset: [0, -8]});\n      tooltip.show();    \n    }\n    setTimeout(function() {\n      if (tooltip) {\n        tooltip.hide();\n        button.removeAttribute(\"data-bs-title\");\n        button.removeAttribute(\"data-bs-toggle\");\n        button.removeAttribute(\"data-bs-placement\");\n      }\n      button.setAttribute(\"title\", currentTitle);\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  }\n  const getTextToCopy = function(trigger) {\n      const codeEl = trigger.previousElementSibling.cloneNode(true);\n      for (const childEl of codeEl.children) {\n        if (isCodeAnnotation(childEl)) {\n          childEl.remove();\n        }\n      }\n      return codeEl.innerText;\n  }\n  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {\n    text: getTextToCopy\n  });\n  clipboard.on('success', onCopySuccess);\n  if (window.document.getElementById('quarto-embedded-source-code-modal')) {\n    // For code content inside modals, clipBoardJS needs to be initialized with a container option\n    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)\n    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {\n      text: getTextToCopy,\n      container: window.document.getElementById('quarto-embedded-source-code-modal')\n    });\n    clipboardModal.on('success', onCopySuccess);\n  }\n    var localhostRegex = new RegExp(/^(?:http|https):\\/\\/localhost\\:?[0-9]*\\//);\n    var mailtoRegex = new RegExp(/^mailto:/);\n      var filterRegex = new RegExp('/' + window.location.host + '/');\n    var isInternal = (href) =&gt; {\n        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);\n    }\n    // Inspect non-navigation links and adorn them if external\n \tvar links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');\n    for (var i=0; i&lt;links.length; i++) {\n      const link = links[i];\n      if (!isInternal(link.href)) {\n        // undo the damage that might have been done by quarto-nav.js in the case of\n        // links that we want to consider external\n        if (link.dataset.originalHref !== undefined) {\n          link.href = link.dataset.originalHref;\n        }\n      }\n    }\n  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n    const config = {\n      allowHTML: true,\n      maxWidth: 500,\n      delay: 100,\n      arrow: false,\n      appendTo: function(el) {\n          return el.parentElement;\n      },\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start',\n    };\n    if (contentFn) {\n      config.content = contentFn;\n    }\n    if (onTriggerFn) {\n      config.onTrigger = onTriggerFn;\n    }\n    if (onUntriggerFn) {\n      config.onUntrigger = onUntriggerFn;\n    }\n    window.tippy(el, config); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i&lt;noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      // use id or data attribute instead here\n      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n      try { href = new URL(href).hash; } catch {}\n      const id = href.replace(/^#\\/?/, \"\");\n      const note = window.document.getElementById(id);\n      if (note) {\n        return note.innerHTML;\n      } else {\n        return \"\";\n      }\n    });\n  }\n  const xrefs = window.document.querySelectorAll('a.quarto-xref');\n  const processXRef = (id, note) =&gt; {\n    // Strip column container classes\n    const stripColumnClz = (el) =&gt; {\n      el.classList.remove(\"page-full\", \"page-columns\");\n      if (el.children) {\n        for (const child of el.children) {\n          stripColumnClz(child);\n        }\n      }\n    }\n    stripColumnClz(note)\n    if (id === null || id.startsWith('sec-')) {\n      // Special case sections, only their first couple elements\n      const container = document.createElement(\"div\");\n      if (note.children && note.children.length &gt; 2) {\n        container.appendChild(note.children[0].cloneNode(true));\n        for (let i = 1; i &lt; note.children.length; i++) {\n          const child = note.children[i];\n          if (child.tagName === \"P\" && child.innerText === \"\") {\n            continue;\n          } else {\n            container.appendChild(child.cloneNode(true));\n            break;\n          }\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(container);\n        }\n        return container.innerHTML\n      } else {\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        return note.innerHTML;\n      }\n    } else {\n      // Remove any anchor links if they are present\n      const anchorLink = note.querySelector('a.anchorjs-link');\n      if (anchorLink) {\n        anchorLink.remove();\n      }\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(note);\n      }\n      // TODO in 1.5, we should make sure this works without a callout special case\n      if (note.classList.contains(\"callout\")) {\n        return note.outerHTML;\n      } else {\n        return note.innerHTML;\n      }\n    }\n  }\n  for (var i=0; i&lt;xrefs.length; i++) {\n    const xref = xrefs[i];\n    tippyHover(xref, undefined, function(instance) {\n      instance.disable();\n      let url = xref.getAttribute('href');\n      let hash = undefined; \n      if (url.startsWith('#')) {\n        hash = url;\n      } else {\n        try { hash = new URL(url).hash; } catch {}\n      }\n      if (hash) {\n        const id = hash.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note !== null) {\n          try {\n            const html = processXRef(id, note.cloneNode(true));\n            instance.setContent(html);\n          } finally {\n            instance.enable();\n            instance.show();\n          }\n        } else {\n          // See if we can fetch this\n          fetch(url.split('#')[0])\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.getElementById(id);\n            if (note !== null) {\n              const html = processXRef(id, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      } else {\n        // See if we can fetch a full url (with no hash to target)\n        // This is a special case and we should probably do some content thinning / targeting\n        fetch(url)\n        .then(res =&gt; res.text())\n        .then(html =&gt; {\n          const parser = new DOMParser();\n          const htmlDoc = parser.parseFromString(html, \"text/html\");\n          const note = htmlDoc.querySelector('main.content');\n          if (note !== null) {\n            // This should only happen for chapter cross references\n            // (since there is no id in the URL)\n            // remove the first header\n            if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n              note.children[0].remove();\n            }\n            const html = processXRef(null, note);\n            instance.setContent(html);\n          } \n        }).finally(() =&gt; {\n          instance.enable();\n          instance.show();\n        });\n      }\n    }, function(instance) {\n    });\n  }\n      let selectedAnnoteEl;\n      const selectorForAnnotation = ( cell, annotation) =&gt; {\n        let cellAttr = 'data-code-cell=\"' + cell + '\"';\n        let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n        return selector;\n      }\n      const selectCodeLines = (annoteEl) =&gt; {\n        const doc = window.document;\n        const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n        const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n        const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n        const lineIds = lines.map((line) =&gt; {\n          return targetCell + \"-\" + line;\n        })\n        let top = null;\n        let height = null;\n        let parent = null;\n        if (lineIds.length &gt; 0) {\n            //compute the position of the single el (top and bottom and make a div)\n            const el = window.document.getElementById(lineIds[0]);\n            top = el.offsetTop;\n            height = el.offsetHeight;\n            parent = el.parentElement.parentElement;\n          if (lineIds.length &gt; 1) {\n            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n            const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n            height = bottom - top;\n          }\n          if (top !== null && height !== null && parent !== null) {\n            // cook up a div (if necessary) and position it \n            let div = window.document.getElementById(\"code-annotation-line-highlight\");\n            if (div === null) {\n              div = window.document.createElement(\"div\");\n              div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n              div.style.position = 'absolute';\n              parent.appendChild(div);\n            }\n            div.style.top = top - 2 + \"px\";\n            div.style.height = height + 4 + \"px\";\n            div.style.left = 0;\n            let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n            if (gutterDiv === null) {\n              gutterDiv = window.document.createElement(\"div\");\n              gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n              gutterDiv.style.position = 'absolute';\n              const codeCell = window.document.getElementById(targetCell);\n              const gutter = codeCell.querySelector('.code-annotation-gutter');\n              gutter.appendChild(gutterDiv);\n            }\n            gutterDiv.style.top = top - 2 + \"px\";\n            gutterDiv.style.height = height + 4 + \"px\";\n          }\n          selectedAnnoteEl = annoteEl;\n        }\n      };\n      const unselectCodeLines = () =&gt; {\n        const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n        elementsIds.forEach((elId) =&gt; {\n          const div = window.document.getElementById(elId);\n          if (div) {\n            div.remove();\n          }\n        });\n        selectedAnnoteEl = undefined;\n      };\n        // Handle positioning of the toggle\n    window.addEventListener(\n      \"resize\",\n      throttle(() =&gt; {\n        elRect = undefined;\n        if (selectedAnnoteEl) {\n          selectCodeLines(selectedAnnoteEl);\n        }\n      }, 10)\n    );\n    function throttle(fn, ms) {\n    let throttle = false;\n    let timer;\n      return (...args) =&gt; {\n        if(!throttle) { // first call gets through\n            fn.apply(this, args);\n            throttle = true;\n        } else { // all the others get throttled\n            if(timer) clearTimeout(timer); // cancel #2\n            timer = setTimeout(() =&gt; {\n              fn.apply(this, args);\n              timer = throttle = false;\n            }, ms);\n        }\n      };\n    }\n      // Attach click handler to the DT\n      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n      for (const annoteDlNode of annoteDls) {\n        annoteDlNode.addEventListener('click', (event) =&gt; {\n          const clickedEl = event.target;\n          if (clickedEl !== selectedAnnoteEl) {\n            unselectCodeLines();\n            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n            if (activeEl) {\n              activeEl.classList.remove('code-annotation-active');\n            }\n            selectCodeLines(clickedEl);\n            clickedEl.classList.add('code-annotation-active');\n          } else {\n            // Unselect the line\n            unselectCodeLines();\n            clickedEl.classList.remove('code-annotation-active');\n          }\n        });\n      }\n  const findCites = (el) =&gt; {\n    const parentEl = el.parentElement;\n    if (parentEl) {\n      const cites = parentEl.dataset.cites;\n      if (cites) {\n        return {\n          el,\n          cites: cites.split(' ')\n        };\n      } else {\n        return findCites(el.parentElement)\n      }\n    } else {\n      return undefined;\n    }\n  };\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i&lt;bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const citeInfo = findCites(ref);\n    if (citeInfo) {\n      tippyHover(citeInfo.el, function() {\n        var popup = window.document.createElement('div');\n        citeInfo.cites.forEach(function(cite) {\n          var citeDiv = window.document.createElement('div');\n          citeDiv.classList.add('hanging-indent');\n          citeDiv.classList.add('csl-entry');\n          var biblioDiv = window.document.getElementById('ref-' + cite);\n          if (biblioDiv) {\n            citeDiv.innerHTML = biblioDiv.innerHTML;\n          }\n          popup.appendChild(citeDiv);\n        });\n        return popup.innerHTML;\n      });\n    }\n  }\n});\n&lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]